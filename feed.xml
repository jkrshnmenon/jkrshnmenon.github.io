<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://jkrshnmenon.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://jkrshnmenon.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-07-18T23:27:55+00:00</updated><id>https://jkrshnmenon.github.io/feed.xml</id><title type="html">Jayakrishna Menon Vadayath</title><subtitle>Random ramblings of a CTF player </subtitle><entry><title type="html">M0lecon CTF 2023 NoRegVM Writeup</title><link href="https://jkrshnmenon.github.io/blog/2023/m0lectf23noregvm/" rel="alternate" type="text/html" title="M0lecon CTF 2023 NoRegVM Writeup"/><published>2023-05-17T15:09:00+00:00</published><updated>2023-05-17T15:09:00+00:00</updated><id>https://jkrshnmenon.github.io/blog/2023/m0lectf23noregvm</id><content type="html" xml:base="https://jkrshnmenon.github.io/blog/2023/m0lectf23noregvm/"><![CDATA[<p>For some reason, I’ve found VM exploitation challenges to be quite interesting recently.</p> <p>I managed to solve a challenge called NoRegVM from M0lecon CTF 2023. I also tried to solve a reversing challenge involving the same binary, but I couldn’t find the final solution. But that’s for another blog post.</p> <h2 id="step-1-reversing">Step 1: Reversing</h2> <p>This program lets you provide the code and memory that a VM is initialized with.</p> <p>The VM can perform 13 different functions including reading and writing to the standard input/output.</p> <p>This VM does not use registers, so all the operands used for an operation should be immediate values or memory addresses. Data can be copied to and from the memory using the <code class="language-plaintext highlighter-rouge">pop_in</code> and <code class="language-plaintext highlighter-rouge">pop_out</code> instructions in the VM.</p> <h2 id="step-2-the-bugs">Step 2: The Bug(s)</h2> <p>I found three bugs in this challenge and I eventually used all of them for the final exploit.</p> <p>The first bug is a buffer overflow vulnerability in the <code class="language-plaintext highlighter-rouge">pop_out</code> function.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/noregvm/popout-480.webp 480w,/assets/img/noregvm/popout-800.webp 800w,/assets/img/noregvm/popout-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/noregvm/popout.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The loop in <code class="language-plaintext highlighter-rouge">pop_out</code> can be executed as many times as we want. This would eventually lead to an out-of-bounds write of the <code class="language-plaintext highlighter-rouge">output</code> buffer.</p> <p>And that leads us to the second bug which is a format string vulnerability in the <code class="language-plaintext highlighter-rouge">write_buf</code> function.</p> <p>Looking at the pseudo-code generated by IDA, this vulnerability is not apparent.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/noregvm/pseudocode-480.webp 480w,/assets/img/noregvm/pseudocode-800.webp 800w,/assets/img/noregvm/pseudocode-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/noregvm/pseudocode.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>However, if you look at the actual assembly code, we see that the format specifier used by <code class="language-plaintext highlighter-rouge">printf</code> is a buffer in the data section of the binary.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/noregvm/assembly-480.webp 480w,/assets/img/noregvm/assembly-800.webp 800w,/assets/img/noregvm/assembly-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/noregvm/assembly.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>And it so happens that this <code class="language-plaintext highlighter-rouge">FMT_STR</code> buffer lies just after the <code class="language-plaintext highlighter-rouge">output</code> buffer.</p> <p>Therefore, by overflowing the <code class="language-plaintext highlighter-rouge">output</code> buffer using the <code class="language-plaintext highlighter-rouge">pop_out</code> function, we can trigger a format string vulnerability in the <code class="language-plaintext highlighter-rouge">write_buf</code> function. This can be used to leak whatever data we need.</p> <p>I ended up leaking the heap, canary, stack, binary and libc base addresses.</p> <p>The final bug is in the <code class="language-plaintext highlighter-rouge">len</code> function.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/noregvm/len-480.webp 480w,/assets/img/noregvm/len-800.webp 800w,/assets/img/noregvm/len-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/noregvm/len.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>In this function again, we can execute the loop as many times as we want. This eventually leads to an out-of-bounds write of the stack buffer of size 200;</p> <h2 id="step-3-the-exploit">Step 3: The Exploit</h2> <p>So the plan was clear,</p> <ul> <li>Overflow `output` buffer to overwrite `FMT_STR`</li> <li>Leak all the pointers</li> <li>Overflow stack buffer in `len` and get PC control</li> <li>????</li> <li>Profit</li> </ul> <p>A slightly annoying part about this challenge is that the loop in the <code class="language-plaintext highlighter-rouge">len</code> function will stop at the first instance of an int value 0. However, only the lower 8 bits from each memory address is copied into the stack buffer. Therefore, if the value at a memory address was 0x0100, the check for 0 would pass while only the last byte (i.e NULL) would be appended to the stack buffer.</p> <p>In order to do this, I modified the program code to generate this 0x100 value (by performing 0x10 * 0x10) and writing it to the indices where I needed NULL bytes.</p> <p>The final exploit uses the leaks in a simple ROP chain to call <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code></p> <p>I had initially written this exploit by hard-coding the opcodes and operand values. And it was very hard to read for someone who didn’t understand my plan.</p> <p>So, after the CTF, I tried re-writing the exploit to use my assembler. And it worked with minimal adjustments! Even I was surprised.</p> <p>The final exploit is available here: <a href="/assets/python/noregvm/exploit.py">Exploit</a></p> <p>And since the assembler will keep getting updated, its better to store it somewhere like <a href="https://github.com/jkrshnmenon/scripts/blob/master/assembler_stuff/assembler.py">GitHub</a>.</p>]]></content><author><name></name></author><category term="writeup"/><category term="stack"/><category term="ctf"/><summary type="html"><![CDATA[Solving the NoRegVM challenge from M0lecon CTF 2023]]></summary></entry><entry><title type="html">OCTF 2022 EZVM Writeup</title><link href="https://jkrshnmenon.github.io/blog/2023/0ctf22ezvm/" rel="alternate" type="text/html" title="OCTF 2022 EZVM Writeup"/><published>2023-01-05T15:09:00+00:00</published><updated>2023-01-05T15:09:00+00:00</updated><id>https://jkrshnmenon.github.io/blog/2023/0ctf22ezvm</id><content type="html" xml:base="https://jkrshnmenon.github.io/blog/2023/0ctf22ezvm/"><![CDATA[<p>Its been some time since I wrote one of these, so I might be a little rusty. Do bear with me.</p> <p>I wasn’t able to play 0CTF 2022 in full while it was going on but I was helping one of my teammates (@zolutal) who was trying to solve this challenge. I had briefly tried to reverse engineer the binary but didn’t have enough time to analyze it completely.</p> <h2 id="step-1-reversing">Step 1: Reversing</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/main-480.webp 480w,/assets/img/ezvm/main-800.webp 800w,/assets/img/ezvm/main-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/main.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The main function doesn’t do much except for that 256 byte long buffer which I thought might be useful in case we needed to fill some constraints for a one-gadget. But I did not end up using that approach.</p> <p>The <code class="language-plaintext highlighter-rouge">do_main</code> function does more interesting stuff by comparison</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/do_main-480.webp 480w,/assets/img/ezvm/do_main-800.webp 800w,/assets/img/ezvm/do_main-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/do_main.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>During my hasty reverse engineering process, I ended up naming the allocation at line 24 as <code class="language-plaintext highlighter-rouge">registers</code> even though the program was basically telling me it was called <code class="language-plaintext highlighter-rouge">memory</code>. So for the rest of this blog, I’ll refer to this allocated region as <code class="language-plaintext highlighter-rouge">memory</code> even though my decompiled code says <code class="language-plaintext highlighter-rouge">registers</code>.</p> <p>The comparison at line 17 stands out pretty well as a possible location for a bug, but I was more interested in reversing the other functions.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/init_vm-480.webp 480w,/assets/img/ezvm/init_vm-800.webp 800w,/assets/img/ezvm/init_vm-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/init_vm.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Init VM clears all of the data before executing the code. However, since it uses <code class="language-plaintext highlighter-rouge">malloc</code>, some of the data on the heap might still be present and available for reuse.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/run_vm-480.webp 480w,/assets/img/ezvm/run_vm-800.webp 800w,/assets/img/ezvm/run_vm-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/run_vm.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>And now we get to the actual VM part.</p> <p>There’s quite a lot of switch cases here. Each instruction is apparently one byte and the VM follows a stack based model. Which means that for an arithmetic operation, two values on the top of the stack are popped off and the result is pushed back on to the stack.</p> <p>The program does make sure that the stack does not overflow or underflow.</p> <p>Line 27 in the above screenshot looked a bit weird to me since it checks if <code class="language-plaintext highlighter-rouge">operand1</code> is lesser than 4 and then adds 4 to it while dereferencing.</p> <p>However, looking at the memory layout, it makes more sense.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/memory-480.webp 480w,/assets/img/ezvm/memory-800.webp 800w,/assets/img/ezvm/memory-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/memory.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Like I had mentioned earlier, the <code class="language-plaintext highlighter-rouge">regs</code> variable that I had named is actually supposed to be called <code class="language-plaintext highlighter-rouge">memory</code>.</p> <p>The VM maintains its own 4 registers each of which is 8 bytes long. These registers are referred to in the decompiled code as <code class="language-plaintext highlighter-rouge">internal_array</code>. And so we have</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="o">&amp;</span><span class="n">regs</span><span class="p">[</span><span class="mi">4</span><span class="o">+</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">internal_array</span><span class="p">[</span><span class="n">x</span><span class="p">]</span></code></pre></figure> <p>This makes the reverse engineering much more understandable.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/jump-480.webp 480w,/assets/img/ezvm/jump-800.webp 800w,/assets/img/ezvm/jump-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/jump.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The VM even supports jump instructions. Although it does make sure that the program counter does not go beyond the bounds of the code section.</p> <h2 id="step-2-the-bug">Step 2: The Bug</h2> <p>I wasn’t able to find the bug here, but @zolutal found it.</p> <p>There are two bugs here that combine together to provide an arbitrary 8-byte write.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/vuln-480.webp 480w,/assets/img/ezvm/vuln-800.webp 800w,/assets/img/ezvm/vuln-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/vuln.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>In line 156, the variable <code class="language-plaintext highlighter-rouge">op2_</code> is an 8 byte value that we can control. So if it is large enough, it can index memory outside the chunk allocated in the <code class="language-plaintext highlighter-rouge">regs</code> variable.</p> <p>However, in order to do that, it must first pass the check at line 154.</p> <p>This is where the second bug comes in.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/do_main_vuln-480.webp 480w,/assets/img/ezvm/do_main_vuln-800.webp 800w,/assets/img/ezvm/do_main_vuln-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/do_main_vuln.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>These lines inside the <code class="language-plaintext highlighter-rouge">do_main</code> function allow us to set the <code class="language-plaintext highlighter-rouge">regs_size</code> variable in the <code class="language-plaintext highlighter-rouge">run_vm</code> function to any value up to 0x2000000000000000 (or 1 « 61 )</p> <p>However, when the allocation happens at the <code class="language-plaintext highlighter-rouge">malloc</code>, this value is multiplied with 8.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">In</span> <span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="nf">hex</span><span class="p">(((</span><span class="mh">0x2000000000000000</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">)</span> \<span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span>\<span class="o">*</span>\<span class="o">*</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="sh">'</span><span class="s">0x80</span><span class="sh">'</span></code></pre></figure> <p>Therefore, when we request an allocation of size 0x2000000000000000 + 0x10, the multiplication overflows into a value 0x80 which is the size of the buffer that <code class="language-plaintext highlighter-rouge">malloc</code> allocates.</p> <p>Now, in <code class="language-plaintext highlighter-rouge">run_vm</code>, the <code class="language-plaintext highlighter-rouge">regs_size</code> is 0x2000000000000000 + 0x10 which allows us to write to memory out of the bounds of the <code class="language-plaintext highlighter-rouge">regs</code> buffer.</p> <p>However, in the switch case number 22 in <code class="language-plaintext highlighter-rouge">run_vm</code>, we cannot use this idea to get an arbitrary read. This is because the comparison in line 162 will first multiply the <code class="language-plaintext highlighter-rouge">regs_size</code> by 8 and then divide the result by 8.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">In</span> <span class="p">[</span><span class="mi">10</span><span class="p">]:</span> <span class="nf">hex</span><span class="p">((((</span><span class="mh">0x2000000000000000</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">)</span> \<span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span>\<span class="o">*</span>\<span class="o">*</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">//</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">10</span><span class="p">]:</span> <span class="sh">'</span><span class="s">0x10</span><span class="sh">'</span></code></pre></figure> <p>This means that we cannot use this functionality to get an arbitrary read.</p> <h2 id="step-3-the-exploit">Step 3: The Exploit</h2> <p>Up until now, the only primitives we had was an arbitrary write. Moreover, we can only trigger this arbitrary overwrite in a single VM after which we cannot reuse it again.</p> <p>With some heap massaging, we can free tcache and smallbin chunks which leave some useful pointers on the heap. But since the VM does not write any content out, we were not able to figure out a way to leak these pointers.</p> <p>One of the ideas that I had was to perform some heap fengshui to position the code buffer after the memory buffer. If we could do that, we could use the arbitrary overwrite to overwrite some values in the code with the pointers that were on the heap. This would’ve been a crazy solution, but it eventually did not work out.</p> <p>And we actually did not solve this challenge during the CTF.</p> <h2 id="step-4-yansquad">Step 4: Yansquad</h2> <p>I forgot about this challenge after some time. But then it showed up in one of the classes that I’m taking here at ASU.</p> <p>CSE 598 Topic: Emerging Cybersecurity Techniques taken by none other than @zardus involved us playing CTF’s and solving challenges together in class.</p> <p>In this class, every week, one student is responsible for picking a challenge from a CTF, deconstructing to its most basic concept and creating a simplified version of the challenge. This one week, it was @clasm’s turn to present a challenge and he chose this one.</p> <p>The simplified version of the challenge provided all the primitives you could ask for in a heap exploitation challenge. And the objective was to learn how to overwrite the <code class="language-plaintext highlighter-rouge">tls_dtors_list</code> to get PC control.</p> <p><del>I’ll put up the files for this challenge as soon as @clasm lets me know its okay to.</del> The files for this simplified challenge are available <a href="/assets/binary/ezvm/simplified.zip">here</a>.</p> <p>But once I had solved the simplified one, I wanted to give another go at the original challenge.</p> <h2 id="step-5-the-leak">Step 5: The Leak</h2> <p>This time I noticed something that I had missed. A sidechannel for leaking pointers.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/side_channel-480.webp 480w,/assets/img/ezvm/side_channel-800.webp 800w,/assets/img/ezvm/side_channel-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/side_channel.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>This switch case (which I called the <code class="language-plaintext highlighter-rouge">nop</code> case) would print a string “what??” when hit.</p> <p>Now, if I can write the code for the VM to perform some checks on the pointers and jump to a <code class="language-plaintext highlighter-rouge">nop</code> instruction if true, I will be able to leak pointers.</p> <h2 id="step-6-the-assembly">Step 6: The Assembly</h2> <p>I really did not want to write bytecode and deal with jump offsets (although maybe it would’ve been faster).</p> <p>So I ended up writing an assembler for this VM that supports labels and loops. It would replace labels with a <code class="language-plaintext highlighter-rouge">nop</code> instruction.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="n">assembler</span> <span class="kn">import</span> \<span class="o">*</span>

<span class="k">def</span> <span class="nf">run_vm</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">mem_count</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
<span class="n">assembler</span> <span class="o">=</span> <span class="nc">Assembler</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span>
<span class="n">code</span> <span class="o">=</span> <span class="n">assembler</span><span class="p">.</span><span class="nf">assemble</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="nf">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">Please input your code size:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="sa">b</span><span class="sh">"</span><span class="s">%d</span><span class="sh">"</span> <span class="o">%</span> <span class="nf">len</span><span class="p">(</span><span class="n">code</span><span class="p">))</span>
<span class="n">p</span><span class="p">.</span><span class="nf">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">Please input your memory count:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="sa">b</span><span class="sh">"</span><span class="s">%d</span><span class="sh">"</span> <span class="o">%</span> <span class="n">mem_count</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="nf">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">Please input your code:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nf">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">finish!</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="nf">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="sh">"</span><span class="s">continue?</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
<span class="k">return</span> <span class="n">out</span></code></pre></figure> <p>I then wrote assembly code that increments a counter from zero in a loop until it becomes equal to one byte of a pointer. In each loop, this program will hit a <code class="language-plaintext highlighter-rouge">nop</code> which will make the program print the string “what??”. And upon counting the number of these strings printed out, I can get the value of this one byte.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">leak</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">):</span>
<span class="n">leak_byte</span> <span class="o">=</span> <span class="sh">"""</span><span class="s">
lq r0 0
push r0
li r3 {byte_idx}
push r3
shr
pop r3
push r3
li r1 0xff
push r1
and
pop r1
li r2 0x1
.loop
push r1
push r2
sub
pop r1
push r1
jnz .loop
hlt
</span><span class="sh">"""</span>
<span class="n">leaked_bytes</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">):</span>
<span class="n">prog</span> <span class="o">=</span> <span class="n">leak_byte</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">byte_idx</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="nf">run_vm</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span> <span class="sa">b</span><span class="sh">"</span><span class="s">B</span><span class="sh">"</span><span class="o">*</span><span class="mi">10</span><span class="p">).</span><span class="nf">decode</span><span class="p">(</span><span class="sh">"</span><span class="s">utf-8</span><span class="sh">"</span><span class="p">).</span><span class="nf">strip</span><span class="p">()</span>
<span class="n">leaked_byte</span> <span class="o">=</span> <span class="n">output</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="sh">"</span><span class="p">).</span><span class="nf">count</span><span class="p">(</span><span class="sh">"</span><span class="s">what???</span><span class="sh">"</span><span class="p">)</span>
<span class="n">leaked_bytes</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaked_byte</span><span class="p">]</span> <span class="o">+</span> <span class="n">leaked_bytes</span>

    <span class="n">leaked_addr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">leaked_bytes</span><span class="p">:</span>
        <span class="n">leaked_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">leaked_addr</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span>

    <span class="n">log</span><span class="p">.</span><span class="nf">success</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Leaked value : </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">leaked_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">leaked_addr</span></code></pre></figure> <h2 id="step-7-the-target">Step 7: The Target</h2> <p>In the version of libc that the challenge uses (libc-2.35), the usual suspects for PC control such as <code class="language-plaintext highlighter-rouge">__free_hook</code> and <code class="language-plaintext highlighter-rouge">__malloc_hook</code> have been removed.</p> <p>But then there’s some code that always gets invoked when the program exits. Namely the <code class="language-plaintext highlighter-rouge">__run_exit_handlers()</code></p> <p>This function calls <code class="language-plaintext highlighter-rouge">__call_tls_dtors()</code> which walks a linked list called <code class="language-plaintext highlighter-rouge">tls_dtor_list</code> and executes the functions specified by each object’s function pointer.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/tls-480.webp 480w,/assets/img/ezvm/tls-800.webp 800w,/assets/img/ezvm/tls-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/tls.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Since we have an arbitrary overwrite, we can overwrite one entry in the linked list to point to an area we control. And with that, we can force the <code class="language-plaintext highlighter-rouge">__call_tls_dtors()</code> function to call a function pointer that we control.</p> <p>So then my plan for exploit was as follows</p> <ul> <li>Heap fengshui to get a heap pointer in the memory buffer</li> <li>Leak pointer to get heap leak</li> <li>Heap fengshui to get a libc pointer in the memory buffer</li> <li>Leak pointer to get libc leak</li> <li>Create fake <code>tls_dtor_list</code> object on heap</li> <li>Overwrite <code>tls_dtor_list</code> with the fake object</li> <li>????</li> <li>Profit</li> </ul> <p>We do have to take care of a pesky <code class="language-plaintext highlighter-rouge">PTR_DEMANGLE</code> macro which is basically a right shift followed by an xor. However, an easy way to fix it is to overwrite the xor key with 0.</p> <p>And putting it all together:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/ezvm/pwned-480.webp 480w,/assets/img/ezvm/pwned-800.webp 800w,/assets/img/ezvm/pwned-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/ezvm/pwned.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The final exploit is available here: <a href="/assets/python/ezvm/exploit.py">Exploit</a></p> <p>And the assembler is available here: <a href="/assets/python/ezvm/assembler.py">Assembler</a></p>]]></content><author><name></name></author><category term="writeup"/><category term="heap"/><category term="ctf"/><summary type="html"><![CDATA[Solving the EZVM challenge from 0CTF 2022]]></summary></entry></feed>