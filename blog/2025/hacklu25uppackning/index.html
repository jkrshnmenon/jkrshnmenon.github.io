<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Hack.lu CTF 2025 UPPACKNING Writeup | Jayakrishna Menon Vadayath </title> <meta name="author" content="Jayakrishna Menon Vadayath"> <meta name="description" content="Solving the UPPACKNING challenge from Hack.lu CTF 2025"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://jkrshnmenon.github.io/blog/2025/hacklu25uppackning/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="//"> Jayakrishna Menon Vadayath </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Hack.lu CTF 2025 UPPACKNING Writeup</h1> <p class="post-meta"> Created in September 06, 2025 </p> <p class="post-tags"> <a href="//blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="//blog/tag/ctf"> <i class="fa-solid fa-hashtag fa-sm"></i> ctf</a>   <a href="//blog/tag/heap"> <i class="fa-solid fa-hashtag fa-sm"></i> heap</a>   <a href="//blog/tag/pwn"> <i class="fa-solid fa-hashtag fa-sm"></i> pwn</a>   ·   <a href="//blog/category/writeup"> <i class="fa-solid fa-tag fa-sm"></i> writeup</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>I cannot honestly remember the last time I tried a heap pwning challenge that was actually fun. So it was very refreshing to play Hack.lu and find so many fascinating challenges. I looked at a couple of challenges, and they were all really good.</p> <p>But, I spent most of the first day of the CTF looking at this UPPACKNING challenge and so this blog post will mostly be about that.</p> <p>Let’s dive right in!</p> <h2 id="the-challenge">The challenge</h2> <p>The zip file for the challenge contains the two binaries that are involved as well as their source code. It also contains all the files for running the target in the docker environment which replicates the one deployed on the server.</p> <p>It also contains the <code class="language-plaintext highlighter-rouge">ynetd</code> binary and its source code. Essentially, this binary acts as a <code class="language-plaintext highlighter-rouge">socat</code> alternative and is only used for spinning up all the binaries needed for this challenge. So, its not really relevant to the challenge.</p> <p>Instead, the relevant binaries are <code class="language-plaintext highlighter-rouge">main</code> and <code class="language-plaintext highlighter-rouge">worker</code>. Once you connect to the server listening on port 1024, you are now communicating with the <code class="language-plaintext highlighter-rouge">main</code> binary. At the same time, a <code class="language-plaintext highlighter-rouge">worker</code> process is also spun up. This process doesn’t communicate with you directly but rather only talks to the <code class="language-plaintext highlighter-rouge">main</code> process.</p> <p>For this purpose, the <code class="language-plaintext highlighter-rouge">main</code> process connects to port 9090 which <code class="language-plaintext highlighter-rouge">ynetd</code> is accepting connections on. Once it connects to this port, <code class="language-plaintext highlighter-rouge">ynetd</code> starts up the <code class="language-plaintext highlighter-rouge">worker</code> process. And now the <code class="language-plaintext highlighter-rouge">main</code> and <code class="language-plaintext highlighter-rouge">worker</code> talk to each other over port 9090.</p> <p>To be precise, <code class="language-plaintext highlighter-rouge">main</code> only sends input to the <code class="language-plaintext highlighter-rouge">worker</code> process. The response from <code class="language-plaintext highlighter-rouge">worker</code> is handled by a <code class="language-plaintext highlighter-rouge">pthread</code> of the <code class="language-plaintext highlighter-rouge">main</code> process.</p> <p>This will be important later!</p> <p>So the <code class="language-plaintext highlighter-rouge">main</code> process spins off a thread which accepts inputs sent through the file-descriptor which is connected to the port 9090. This thread continuously loops and waits for messages on this file-descriptor. I’ll call this <code class="language-plaintext highlighter-rouge">thread #2</code></p> <p>The <code class="language-plaintext highlighter-rouge">main</code> thread (<code class="language-plaintext highlighter-rouge">thread #1</code>) listens on STDIN and offers a file-system like service where you can create/delete/list files and view/modify their contents. We are also allowed to uncompress the files which happens using a <code class="language-plaintext highlighter-rouge">Zstandard (zstd)</code> uncompression.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Commands</span> <span class="p">{</span>
    <span class="n">Create</span><span class="p">,</span>
    <span class="n">Read</span><span class="p">,</span>
    <span class="n">Write</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Delete</span><span class="p">,</span>
    <span class="n">Uncompress</span><span class="p">,</span>
    <span class="n">ReadUncompressed</span><span class="p">,</span>
    <span class="n">DeleteUncompressed</span><span class="p">,</span>
    <span class="n">Exit</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div> <p>The compressed and uncompressed files are kept in separate arrays. We are allowed to read from and delete the uncompressed files, but we cannot modify the uncompressed files.</p> <p>The uncompression happens in the <code class="language-plaintext highlighter-rouge">worker</code> process. When you request a file to be uncompressed, the <code class="language-plaintext highlighter-rouge">thread #1</code> in the <code class="language-plaintext highlighter-rouge">main</code> process sends the contents of the compressed file to the <code class="language-plaintext highlighter-rouge">worker</code> process. The <code class="language-plaintext highlighter-rouge">worker</code> then uncompresses the file and sends it back to <code class="language-plaintext highlighter-rouge">thread #2</code> in the <code class="language-plaintext highlighter-rouge">main</code> process which creates the uncompressed file with the new contents it received.</p> <p>This communication between the <code class="language-plaintext highlighter-rouge">main</code> process and <code class="language-plaintext highlighter-rouge">worker</code> process occurs through a custom protocol.</p> <h2 id="the-protocol">The protocol</h2> <p>The source code for this protocol is provided which resembles a hybrid between TCP and UDP. There’s a limit to the amount of data that can be sent through this protocol at a time (which is &lt;0xFD or 253). This means that larger files are split up into fragments before sending. And these fragments are reassembled upon reception.</p> <p>It resembles TCP in the sense that each fragment contains a index value which specifies the index of this fragment in the large file. It resembles UDP in the sense that the sender does not check whether the receiver has responded with an acknowledgement or not. If an error happens during transmission, the receiver simply stops receiving packets and resets it state.</p> <p>For files that are smaller than the limit, the entire file is sent as a whole. In order to differentiate between a fragmented file and a single file, the protocol uses the first byte of the data.</p> <p>A value of 0 in the first byte indicates that this data contains the entire file. Whereas a value of 1, indicates that this data is a fragment of a larger file.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Receiver side</span>
<span class="kt">void</span> <span class="nf">packetio_frame_receive</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">Single</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">receive_frame_single</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">packet_io</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">Fragmented</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">receive_frame_fragmented</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">packet_io</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="c1">// Sender side</span>
<span class="kt">void</span> <span class="nf">send_fragment_single</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fragment</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
    <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Single</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="kt">void</span> <span class="nf">send_fragment_fragmented</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fragment</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
            <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fragmented</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>If the data being sent is a fragment of a file, the second byte of the data indicates the index of this fragment. When the first fragment is being sent, this byte contains the total number of fragments that are expected.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Receiver side</span>
<span class="kt">void</span> <span class="nf">receive_frame_fragmented</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">n_fragments</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">n_fragments</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>  <span class="o">&lt;-------</span> <span class="n">Byte</span> <span class="n">at</span> <span class="n">offset</span> <span class="mi">1</span> <span class="n">indicates</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">frames</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="c1">// Sender side</span>
<span class="kt">void</span> <span class="n">send_fragment_fragmented</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fragment</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
            <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fragmented</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_first_fragment</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_n_fragments</span><span class="p">;</span>  <span class="o">&lt;---------</span> <span class="n">Set</span> <span class="n">here</span>
                <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_first_fragment</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>Once the first frame of a fragment has been sent, the next frame will contain frame indices starting from 0. The sender and receiver keep track of the total number of frames sent and they will stop when their counter becomes equal to <code class="language-plaintext highlighter-rouge">total_frames - 1</code> (or <code class="language-plaintext highlighter-rouge">total_frames - 2</code> in the case of the receiver).</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Receiver side</span>
<span class="kt">void</span> <span class="nf">receive_frame_fragmented</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
        <span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">fragment_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">n_fragments</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">last</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">n_fragments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="c1">// Sender side</span>
<span class="kt">void</span> <span class="nf">send_fragment_fragmented</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fragment</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_fragment_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_n_fragments</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_n_fragments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>That pretty much sums up the important parts of the protocol.</p> <p>Only thing left to do is to find the vuln, pwn and <code class="language-plaintext highlighter-rouge">cat flag</code>.</p> <h2 id="the-vulnerability">The vulnerability</h2> <p>Since the organizers provided the source code for this challenge, you’d think finding the vulnerability would be easy.</p> <p>To be fair, Claude was able to find a buffer-overread when you read from an uncompressed file very quickly. This could be useful for memory leaks.</p> <p>However, it took @zolutal and I around 12 hours to find a memory corruption bug. During that time, we came up with so many theories on what the vulnerability could be. In fact, we were convinced that it had to be a race-condition vulnerability.</p> <p>At one point, I was absolutely certain that the vulnerability had to occur when the receiver was calculating <code class="language-plaintext highlighter-rouge">packet_io-&gt;fragment_index + 2</code> since <code class="language-plaintext highlighter-rouge">fragment_index</code> was a <code class="language-plaintext highlighter-rouge">uint8_t</code> which would lead to an integer overflow.</p> <p>However, this was not happening since the <code class="language-plaintext highlighter-rouge">uint8_t</code> was promoted to a 32 bit integer before the addition.</p> <p>I was so full of myself and asked the organizers if there was a mistake in the challenge since no one had pwned it at that point. That was a very dumb move on my part.</p> <p>However, after many more hours of talking to Claude and brainstorming possibilities, I finally found the bug.</p> <p>So, when a file is being uncompressed, the <code class="language-plaintext highlighter-rouge">worker</code> uses a function <code class="language-plaintext highlighter-rouge">ZSTD_getFrameContentSize</code> to calculate how big the uncompressed file will be. As it turns out, you can just lie about the total size in the header of a compressed file and this function will happily return this fake value. And the actual uncompression (decompression?) can create a buffer with a smaller length.</p> <p>Now, this fake size value returned by <code class="language-plaintext highlighter-rouge">ZSTD_getFrameContentSize</code> is used by the sender to calculate the number of fragments to be sent. This total number of fragments value goes in the second byte of the first frame sent.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">packetio_fragment_init</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">max_len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">max_len</span> <span class="o">&gt;</span> <span class="n">MAX_FRAGMENTS</span> <span class="o">*</span> <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">max_fragment_data</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// MAX_FRAGMENTS = 255</span>
        <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_n_fragments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                             <span class="c1">// max_fragment_data = 253</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_n_fragments</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">max_fragment_data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>However, once the sender start sending the frames, it uses the length of the buffer actually generated by the uncompression done by <code class="language-plaintext highlighter-rouge">ZSTD_decompressStream</code>. The sender stops sending any new frames when the total number of bytes it has sent becomes equal to the total number of bytes generated by the uncompression.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">void</span> <span class="nf">send_fragment_fragmented</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">fragment</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">PacketIO_t</span> <span class="o">*</span><span class="n">packet_io</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">copy_len</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">max_fragment_data</span> <span class="o">-</span> <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_buf_index</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_buf</span> <span class="o">+</span> <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_buf_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">fragment</span><span class="p">,</span> <span class="n">copy_len</span><span class="p">);</span>
        <span class="n">packet_io</span><span class="o">-&gt;</span><span class="n">send_buf_index</span> <span class="o">+=</span> <span class="n">copy_len</span><span class="p">;</span>
        <span class="n">fragment</span> <span class="o">+=</span> <span class="n">copy_len</span><span class="p">;</span>
        <span class="n">len</span> <span class="o">-=</span> <span class="n">copy_len</span><span class="p">;</span>
        <span class="p">...</span>
    <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>What this effectively means is that the sender can initially tell the receiver to expect N frames, but then only go on to send M frames where <code class="language-plaintext highlighter-rouge">M&lt;N</code>.</p> <p>Since the receiver doesn’t know that the sender has stopped sending frames, it will continue to wait for the <code class="language-plaintext highlighter-rouge">M+1</code> frame to arrive.</p> <p>At this point, if we send another file to be uncompressed, the sender will restart its process of calculating fragments and send the first frame of this new file with the new total number of fragments <code class="language-plaintext highlighter-rouge">P</code>.</p> <p>Now, the receiver is expecting a value of <code class="language-plaintext highlighter-rouge">M+1</code> in the frame index (byte offset 1), but it sees a frame with a value <code class="language-plaintext highlighter-rouge">P</code>. If <code class="language-plaintext highlighter-rouge">P != M+1</code>, this doesn’t follow the expected frame index and so the receiver resets its state after dropping this frame.</p> <p>The sender however, goes on to send the next frame (which starts at index 0). When the receiver sees this frame, it assumes that the byte at offset 1 contains the total number of expected fragments which in this case is 0.</p> <p>The receiver then allocates a buffer of size 0 to hold this frame (of length 0xFD) and then copies the first frame into this buffer. And boom! There’s our memory corruption.</p> <p>It took me a little bit of time, trying to coax ChatGPT to give me a python script that generated a <code class="language-plaintext highlighter-rouge">zstd</code> compressed input which satisfies my requirements. And also some time to debug this multi-binary setup. But, around midnight, I had a Proof-of-Concept which replicates this buffer-overflow.</p> <p>About time!!</p> <h2 id="the-exploit">The exploit</h2> <p>So far, we had a memory read and a memory write on the heap. And so we figured, it’d be an easy solve from this point onwards, right ? Thinking this, we passed off this challenge to one of the newer CTF members @Sammy.</p> <p>However, there were quite a few more complications required to finish the exploit.</p> <p>Since in this challenge, the <code class="language-plaintext highlighter-rouge">thread #1</code> which allowed users to create compressed files was using <code class="language-plaintext highlighter-rouge">calloc</code> which does not use the <code class="language-plaintext highlighter-rouge">tcache</code>. However, <code class="language-plaintext highlighter-rouge">thread #2</code> does use <code class="language-plaintext highlighter-rouge">malloc</code>, but it never free’s anything. All the deletion of compressed and uncompressed files happens within <code class="language-plaintext highlighter-rouge">thread #1</code>. Any pointer allocated by <code class="language-plaintext highlighter-rouge">thread #2</code> was going into the <code class="language-plaintext highlighter-rouge">tcache</code> of <code class="language-plaintext highlighter-rouge">thread #1</code> when it was freeing this pointer.</p> <p>To summarize, in <code class="language-plaintext highlighter-rouge">thread #1</code>, we could not retrieve anything from the <code class="language-plaintext highlighter-rouge">tcache</code>. And in <code class="language-plaintext highlighter-rouge">thread #2</code>, we could not push more than one chunk into the <code class="language-plaintext highlighter-rouge">tcache</code> for each bin.</p> <p>Unfortunately, we could not finish this challenge during the CTF. And so I spent my Sunday evening working on it.</p> <p>I thought that the way to exploit this challenge would be to use <code class="language-plaintext highlighter-rouge">fastbins</code> and then fake a chunk in the stack which would allow me to get a ROP chain working. Since, you need to ensure that the FD of the fake chunk you’re trying to allocate is valid, you’re restricted to only allocating fake chunks on locations where you control at least 13 bytes. And one of the locations that you could control was the stack of the function that reads from the file descriptors. In fact, I found that the offset from the heap base of <code class="language-plaintext highlighter-rouge">thread #2</code> to its stack had only 16 bits that were changing. So it could potentially be brute-forced in 65,536 attempts. Which is not too bad.</p> <p>So I went down this rabbit hole of trying to get a <code class="language-plaintext highlighter-rouge">fastbin</code> in the stack of <code class="language-plaintext highlighter-rouge">thread #2</code>. After many hours, I had finally achieved my goal and had leaked the stack canary and could not overwrite the saved RIP of <code class="language-plaintext highlighter-rouge">thread #2</code>.</p> <p>At this point, I realized the importance of planning ahead when I found that <code class="language-plaintext highlighter-rouge">thread #2</code> was never returning from its loop of waiting for new messages. Even though <code class="language-plaintext highlighter-rouge">thread #1</code> had the option to exit, <code class="language-plaintext highlighter-rouge">thread #2</code> would just continue looping until its killed by the OS. This meant that my effort was wasted and I would never be able to trigger my ROP chain.</p> <h2 id="the-better-exploit">The better exploit</h2> <p>After I spent some amount of time reading the source code of <code class="language-plaintext highlighter-rouge">malloc</code>(which had changed quite a bit from the last time I read it, which was around 2020 or so), I realized that <code class="language-plaintext highlighter-rouge">fastbins</code> would be converted to <code class="language-plaintext highlighter-rouge">tcache</code> entries if their sizes matched.</p> <p>So, if I had filled up the <code class="language-plaintext highlighter-rouge">tcache</code> bin in <code class="language-plaintext highlighter-rouge">thread #1</code> with 7 chunks and had 3 chunks in its <code class="language-plaintext highlighter-rouge">fastbin</code>, the next call to <code class="language-plaintext highlighter-rouge">malloc</code> would move those three <code class="language-plaintext highlighter-rouge">fastbin</code> chunks into the <code class="language-plaintext highlighter-rouge">tcache</code> of <code class="language-plaintext highlighter-rouge">thread #2</code>.</p> <p>With <code class="language-plaintext highlighter-rouge">tcache</code>, since we’re no longer constrained by the 13 controllable bytes requirement, I proceeded to allocate a fake chunk over the compressed file array. With this array, I could now arbitrarily read from any address since I controlled the <code class="language-plaintext highlighter-rouge">data</code> and <code class="language-plaintext highlighter-rouge">size</code> values for each file.</p> <p>And from there, all I needed to do was to overwrite one of the function pointers which was being used as a callback by the protocol and change its value to <code class="language-plaintext highlighter-rouge">system</code> and request compressing a file that contained <code class="language-plaintext highlighter-rouge">;sh\x00</code> as its contents.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ❯ python exploit.py
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/tmp/chall/main'</span>
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    RUNPATH:    b<span class="s1">'.'</span>
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/tmp/chall/libc.so.6'</span>
    Arch:       amd64-64-little
    RELRO:      Full RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        PIE enabled
    FORTIFY:    Enabled
    SHSTK:      Enabled
    IBT:        Enabled
<span class="o">[</span>+] Opening connection to localhost on port 1024: Done
<span class="nv">$ </span><span class="nb">ls
</span>flag
ld-linux-x86-64.so.2
libc.so.6
main
ynetd
<span class="nv">$ </span><span class="nb">cat </span>flag
flag<span class="o">{</span><span class="k">**********</span><span class="o">}</span>
<span class="nv">$ </span>
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Closed connection to localhost port 1024
</code></pre></div></div> <p>Overall, this was a fun challenge and I really enjoyed solving it. As well as the other challenges from this CTF.</p> <p>The files for this challenge are available <a href="/assets/binary/hack.lu/UPPACKNING.zip">here</a>.</p> <p>And my exploit script is <a href="/assets/python/hack.lu/exploit.py">here</a>.</p> <h2 id="extra-credit">Extra Credit</h2> <p>Since I never got to try out the brute-force approach of guessing the <code class="language-plaintext highlighter-rouge">pthread</code> stack base from its heap address, I wanted to give it a shot and see whether or not it was actually possible.</p> <p>And to test it, I created a simple C program that would allocate a heap pointer and a stack buffer and print out the start address of their respective segments by reading from <code class="language-plaintext highlighter-rouge">/proc/self/maps</code>.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mh">0x100</span><span class="p">];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x100</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"malloc"</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">uint64_t</span> <span class="n">stack_start</span> <span class="o">=</span> <span class="n">find_mapping_start</span><span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">heap_start</span> <span class="o">=</span> <span class="n">find_mapping_start</span><span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">p</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%#lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">stack_start</span> <span class="o">-</span> <span class="n">heap_start</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>And I wrote a python script to run this program 1000 times and collect the offset values. And after analyzing the offset values, it turns out that there’s only 5 bits that are actually random in these offset values.</p> <p>Now, what’s more fascinating is that the stack of this <code class="language-plaintext highlighter-rouge">pthread</code> is also contiguous with the <code class="language-plaintext highlighter-rouge">libc</code> base. Which basically means that if you have leaks of the heap in a <code class="language-plaintext highlighter-rouge">pthread</code>, you can predict addresses of its stack and <code class="language-plaintext highlighter-rouge">libc</code> within 32 attempts!!!</p> <pre>
<span style="color:#ccc;">●→</span> <span style="color:#ffcc00;">0x5555555553ad</span> <span style="color:#ffffff;">&lt;thread_func+0000&gt;</span> <span style="color:#8be9fd;font-weight:bold;">endbr64</span>
  <span style="color:#ffcc00;">0x5555555553b1</span> <span style="color:#ffffff;">&lt;thread_func+0004&gt;</span> <span style="color:#8be9fd;font-weight:bold;">push</span>   <span style="color:#ffffff;">rbp</span>
  <span style="color:#ffcc00;">0x5555555553b2</span> <span style="color:#ffffff;">&lt;thread_func+0005&gt;</span> <span style="color:#8be9fd;font-weight:bold;">mov</span>    <span style="color:#ffffff;">rbp</span>, <span style="color:#ffffff;">rsp</span>

<span style="color:cyan;">gef➤</span>  <span style="color:lightgreen;">vmmap $rsp</span>
<span style="color:#999;">[ Legend:  Code | Heap | Stack ]</span>
<span style="color:#ffcc00;">Start</span>              <span style="color:#ffcc00;">End</span>                <span style="color:#ffcc00;">Offset</span>             <span style="color:#ff79c6;">Perm</span> <span style="color:#cccccc;">Path</span>
<span style="color:#f1fa8c;">0x00007ffff7400000</span> <span style="color:#f1fa8c;">0x00007ffff7c00000</span> <span style="color:#f1fa8c;">0x0000000000000000</span> <span style="color:#ff79c6;">rw-</span>                <span style="color:#aaaaaa;">&lt;----------- THREAD STACK</span>

<span style="color:cyan;">gef➤</span>  <span style="color:lightgreen;">vmmap</span>
<span style="color:#999;">[ Legend:  Code | Heap | Stack ]</span>
<span style="color:#ffcc00;">Start</span>              <span style="color:#ffcc00;">End</span>                <span style="color:#ffcc00;">Offset</span>             <span style="color:#ff79c6;">Perm</span> <span style="color:#cccccc;">Path</span>
<span style="color:#999;">...</span>
<span style="color:#f1fa8c;">0x0000555555559000</span> <span style="color:#f1fa8c;">0x000055555557a000</span> <span style="color:#f1fa8c;">0x0000000000000000</span> <span style="color:#ff79c6;">rw-</span> <span style="color:#cccccc;">[heap]</span>         <span style="color:#aaaaaa;">&lt;----------- MAIN HEAP</span>
<span style="color:#f1fa8c;">0x00007ffff0000000</span> <span style="color:#f1fa8c;">0x00007ffff0021000</span> <span style="color:#f1fa8c;">0x0000000000000000</span> <span style="color:#ff79c6;">rw-</span>                <span style="color:#aaaaaa;">&lt;----------- THREAD HEAP</span>
<span style="color:#999;">...</span>
<span style="color:#f1fa8c;">0x00007ffff73ff000</span> <span style="color:#f1fa8c;">0x00007ffff7400000</span> <span style="color:#f1fa8c;">0x0000000000000000</span> <span style="color:#ff79c6;">---</span> 
<span style="color:#f1fa8c;">0x00007ffff7400000</span> <span style="color:#f1fa8c;">0x00007ffff7c00000</span> <span style="color:#f1fa8c;">0x0000000000000000</span> <span style="color:#ff79c6;">rw-</span>                <span style="color:#aaaaaa;">&lt;----------- THREAD STACK</span>
<span style="color:#f1fa8c;">0x00007ffff7c00000</span> <span style="color:#f1fa8c;">0x00007ffff7c28000</span> <span style="color:#f1fa8c;">0x0000000000000000</span> <span style="color:#50fa7b;">r--</span> <span style="color:#cccccc;">/usr/lib/x86_64-linux-gnu/libc.so.6</span>
</pre> <p>Here’s the probabilities for each bit in the offset from <code class="language-plaintext highlighter-rouge">pthread</code> heap base to stack base plotted.</p> <p><img src="/assets/img/hack.lu/Predict.png" alt="Predict.png"></p> <p>And if you would like to run the same experiment, the files for it are available <a href="/assets/binary/hack.lu/predict.zip">here</a></p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="//blog/2025/asisctf25fileno/">ASIS CTF 2025 File No! Writeup</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="//blog/2024/m0lectf24ducts/">M0lecon CTF Teaser 2024 ducts Writeup</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="//blog/2023/m0lectf23noregvm/">M0lecon CTF 2023 NoRegVM Writeup</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="//blog/2023/0ctf22ezvm/">OCTF 2022 EZVM Writeup</a> </li> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 Jayakrishna Menon Vadayath. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-LM199MC2FW"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-LM199MC2FW");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> </body> </html>